[< Назад](..%2F..%2FREADME.md)

# Руководство по String pool в Java

[Оригинал статьи](https://topjava.ru/blog/rukovodstvo-po-string-pool-v-java#5)

## Класс String

Класс _String_ отвечает за создание строк, состоящих из символов. А если быть точнее, заглянув в реализацию и посмотрев
способ их хранения, то строки представляют собой массив символов (так было до Java 9):

```
private final char value[];
```

Начиная с Java 9 строки хранятся как массив байт:

```
private final byte[] value;
```

Причину смены используемого типа вы можете узнать тут: [Компактные строки в Java 9](compact_strings_in_java_9.md)

Строки в Java являются immutable, т. е. неизменяемыми.

Создать объект класса String можно двумя способами: при помощи строкового литерала и конструктора.

Первый способ, а он является рекомендуемым, удобен и прост. Под строковым литералом понимается последовательность
символов, заключенных в двойные кавычки (**литералы**):

```
String stringLiteral = "TopJava";
```

Класс String имеет в своем распоряжении множество конструкторов, которые могут принимать на вход данные разного типа.
Например, строковый литерал:

```
String stringViaConstructor = new String("TopJava");
```

или массив символов:

```
char[] chars = { 'T', 'o', 'p', 'J', 'a', 'v', 'a' };
String str = new String(chars);
```

Рассмотрим механизм создания и хранения строк более подробно.

## Интернирование строк

Экземпляр класса String хранится в памяти, именуемой куча (heap), но есть некоторые нюансы. Если строка, созданная при
помощи конструктора хранится непосредственно в куче, то строка, созданная как строковый литерал, уже хранится в
специальном месте кучи — в так называемом пуле строк (string pool). В нем сохраняются исключительно уникальные значения
строковых литералов, а не все строки подряд. Процесс помещения строк в пул называется интернирование (от англ.
interning).

Когда мы объявляем переменную типа String и присваиваем ей строковый литерал, то JVM обращается в пул строк и ищет там
такое же значение. Если пул содержит необходимое значение, то компилятор просто возвращает ссылку на соответствующий
адрес строки без выделения дополнительной памяти. Если значение не найдено, то новая строка будет интернирована, а
ссылка на нее возвращена и присвоена переменной.

**Пример:**

```java
public class StringExampleOne {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
    }
}
```

Результат выполнения программы:

![carbon_27.png](..%2Fimages%2Fstring-pool-in-java%2Fcarbon_27.png)

Напомним, что знак «==» сравнивает ссылки на объекты, а не их значения. Результат выполнения программы подтверждает, что
строки str1 и str2 ссылаются на одно и то же место в памяти в пуле строк.

Иллюстративно это выглядит так:

![Frame_197.jpg](..%2Fimages%2Fstring-pool-in-java%2FFrame_197.jpg)

В следующем примере попробуем «склеить» строковые литералы и посмотрим, влияет ли конкатенация на результат:

```java
public class StringExampleTwo {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "Top" + "Java";

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
    }
}
```

Результат выполнения программы:

![carbon_28.png](..%2Fimages%2Fstring-pool-in-java%2Fcarbon_28.png)

В строке «Top» + «Java» создаются два строковых объекта со значениями «Top» и «Java», которые помещаются в пул.
«Склеенные» строки образуют еще одну строку со значением «TopJava», ссылка на которую берется из пула строк (а не
создается заново), т.к. она была интернирована в него ранее.

Значения всех строковых литералов из данного примера известно на этапе компиляции.

Иллюстративно итоговый результат выглядит так:

![Frame_215.jpg](..%2Fimages%2Fstring-pool-in-java%2FFrame_215.jpg)

А теперь давайте рассмотрим еще один пример, который выдаст неожиданный результат:

![carbon_29.png](..%2Fimages%2Fstring-pool-in-java%2Fcarbon_29.png)

Схематично это выглядит примерно так:

![Frame_201_1.jpg](..%2Fimages%2Fstring-pool-in-java%2FFrame_201_1.jpg)

Причиной получения false является то, что интернирование происходит не во время работы приложения (runtime), а во время
компиляции. А т.к. значение строки str3 вычисляется во время выполнения приложения, то на этапе компиляции оно не
известно и потому, не добавляется в пул строк.

## Создание строк с помощью конструктора

Теперь давайте рассмотрим детальнее процесс создания объекта String при помощи конструктора.

Когда мы создаем экземпляр класса String с помощью оператора new, компилятор размещает строки в куче. При этом каждая
строка, созданная таким способом, помещается в кучу (и имеет свою ссылку), даже если такое же значение уже есть в куче
или в пуле строк.

Создадим строки через интернирование и с помощью конструктора, а затем сравним их ссылки:

```java
public class StringExampleFour {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";
        String str3 = new String("TopJava");
        String str4 = new String("TopJava");

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
        System.out.println("Строка 2 равна строке 3? " + (str2 == str3));
        System.out.println("Строка 3 равна строке 4? " + (str3 == str4));
    }
}
```

Результат выполнения программы:

![carbon_30.png](..%2Fimages%2Fstring-pool-in-java%2Fcarbon_30.png)

Иллюстративно это выглядит так:

![Frame_214.png](..%2Fimages%2Fstring-pool-in-java%2FFrame_214.png)

Таким образом, создав четыре одинаковых строки, в памяти зафиксируются только три объекта. Согласитесь, что это
нерационально.

## Ручное интернирование

В Java существует возможность вручную выполнить интернирование строки в пул путем вызова метода intern() у объекта типа
String. Видоизменим приведенный ранее пример, добавив метод intern() к созданным при помощи конструктора строкам:

```java
public class StringExampleFive {

    public static void main(String[] args) {
        String str1 = "TopJava";
        String str2 = "TopJava";
        String str3 = (new String("TopJava")).intern();
        String str4 = (new String("TopJava")).intern();

        System.out.println("Строка 1 равна строке 2? " + (str1 == str2));
        System.out.println("Строка 2 равна строке 3? " + (str2 == str3));
        System.out.println("Строка 3 равна строке 4? " + (str3 == str4));
    }
}
```

Результат выполнения программы:

![carbon_31.png](..%2Fimages%2Fstring-pool-in-java%2Fcarbon_31.png)

Иллюстративно это выглядит так:

![Frame_202.jpg](..%2Fimages%2Fstring-pool-in-java%2FFrame_202.jpg)