[< Назад](..%2F..%2FREADME.md)

<!-- TOC -->

* [Java](#java)
    * [Перечислите методы класса Object](#перечислите-методы-класса-object)
    * [Что появилось в Java 11](#что-появилось-в-java-11)
    * [Чем отличается Set от List](#чем-отличается-set-от-list)
    * [Что использовали для тестов](#что-использовали-для-тестов)
    * [Что использовали для оптимизации кода](#что-использовали-для-оптимизации-кода)
    * [Что такое мутабельность и иммутабельность](#что-такое-мутабельность-и-иммутабельность)
    * [У нас есть класс “джава ланг стринг”. Как он устроен?](#у-нас-есть-класс-джава-ланг-стринг-как-он-устроен)
    * [Что такое “внутренние библиотеки”?](#что-такое-внутренние-библиотеки)
    * [Помимо индексов сталкивались с балансированием деревьев?](#помимо-индексов-сталкивались-с-балансированием-деревьев)
    * [В узлах деревьев должны быть имутабельные объекты, что это такое?](#в-узлах-деревьев-должны-быть-имутабельные-объекты-что-это-такое)
    * [У вас возникла задача разработать неизменяемый объект, который вы будете применять в деревьях. Как вы будете его разрабатывать?](#у-вас-возникла-задача-разработать-неизменяемый-объект-который-вы-будете-применять-в-деревьях-как-вы-будете-его-разрабатывать)
    * [Как вы оцениваете трудоемкость реализации на бекэнде?](#как-вы-оцениваете-трудоемкость-реализации-на-бекэнде)
        * [1. Требования к проекту](#1-требования-к-проекту)
        * [2. Технологический стек](#2-технологический-стек)
        * [3. Команда](#3-команда)
        * [4. Процесс разработки](#4-процесс-разработки)
        * [5. Управление проектом](#5-управление-проектом)
    * [Что такое Lambda?](#что-такое-lambda)
    * [Что такое функциональный интерфейс?](#что-такое-функциональный-интерфейс)
    * [Сигнатуры функций?](#сигнатуры-функций)
    * [Максимально глубоко рассказать про HashMap](#максимально-глубоко-рассказать-про-hashmap)
    * [Можно ли в HashMap использовать null в качестве ключа](#можно-ли-в-hashmap-использовать-null-в-качестве-ключа)
    * [Можно ли в ConcurrentMap использовать null в качестве ключа](#можно-ли-в-concurrentmap-использовать-null-в-качестве-ключа)
    * [В каком тайме упадет IllegalStateException (Compile или Runtime)](#в-каком-тайме-упадет-illegalstateexception-compile-или-runtime)
    * [Что будет в результате Stream.of(“1”,”2”,”3”,”4”).filter(v ->v.equals(“1”))](#что-будет-в-результате-streamof1234filterv--vequals1)
    * [Что такое Stream API?](#что-такое-stream-api)
    * [Что такое функции высшего порядка?](#что-такое-функции-высшего-порядка)
    * [Что такое InputStream и OutputStream и как они связаны со Stream API?](#что-такое-inputstream-и-outputstream-и-как-они-связаны-со-stream-api)
    * [Что вы вкладываете в слово поток?](#что-вы-вкладываете-в-слово-поток)
    * [Что такое потоковый режим?](#что-такое-потоковый-режим)
    * [В каких операциях нужно два элемента?](#в-каких-операциях-нужно-два-элемента)
    * [Операции в Stream API, они как-то отличаются друг от друга? Разновидности?](#операции-в-stream-api-они-как-то-отличаются-друг-от-друга-разновидности)
    * [Как работают стримы под капотом](#как-работают-стримы-под-капотом)
    * [Можно ли вызвать дважды у одного стрима терминирующий метод](#можно-ли-вызвать-дважды-у-одного-стрима-терминирующий-метод)
    * [Как посмотреть все ветки в git](#как-посмотреть-все-ветки-в-git)
    * [Как посмотреть все удаленные репы в git](#как-посмотреть-все-удаленные-репы-в-git)
    * [Что такое git flow](#что-такое-git-flow)
    * [Работали ли вы с базами данных?](#работали-ли-вы-с-базами-данных)
    * [С какими базами работали](#с-какими-базами-работали)
    * [Какие не реляционные СУБД использовал (IN-Memory в т.ч.)](#какие-не-реляционные-субд-использовал-in-memory-в-тч)
    * [Отличия реляционных и нереляционных](#отличия-реляционных-и-нереляционных)
    * [Как работать с реляционными базами данных?](#как-работать-с-реляционными-базами-данных)
    * [Что такое транзакции в базах данных?](#что-такое-транзакции-в-базах-данных)
    * [Что значит “данные остаются консистентными и согласованными”?](#что-значит-данные-остаются-консистентными-и-согласованными)
    * [Как сделать так, чтобы к окончанию транзакции мы точно знали, что всё посчитается корректно, посчитаются даже параллельные транзакции?](#как-сделать-так-чтобы-к-окончанию-транзакции-мы-точно-знали-что-всё-посчитается-корректно-посчитаются-даже-параллельные-транзакции)
    * [Что такое “оптимистичная блокировка”?](#что-такое-оптимистичная-блокировка)
    * [Что такое “пессимистичная блокировка”? Как это реализуетя в коде?](#что-такое-пессимистичная-блокировка-как-это-реализуетя-в-коде)
    * [Как происходила доставка схемы до базы данных?](#как-происходила-доставка-схемы-до-базы-данных)
    * [Что такое ОРМ?](#что-такое-орм)
    * [Что такое JDBC](#что-такое-jdbc)
    * [Что такое JPA](#что-такое-jpa)
    * [Что такое реляция?](#что-такое-реляция)
    * [Criteria API](#criteria-api)
    * [Что делает Explain](#что-делает-explain)
    * [Что такое репликация и шардирование](#что-такое-репликация-и-шардирование)
    * [Работы с транзакциями в Hibernate](#работы-с-транзакциями-в-hibernate)
    * [Кеширование в Hibernate](#кеширование-в-hibernate)
    * [Управление схемами данных](#управление-схемами-данных)
    * [Отличие Inner Join от Left Join](#отличие-inner-join-от-left-join)
        * [INNER JOIN](#inner-join)
        * [LEFT JOIN (LEFT OUTER JOIN)](#left-join-left-outer-join)
        * [Основные различия](#основные-различия)
    * [Отличие Join от Union](#отличие-join-от-union)
        * [JOIN](#join)
        * [UNION](#union)
        * [Основные отличия](#основные-отличия)
    * [Как работает индексация](#как-работает-индексация)
    * [В чем отличия EAGER от LAZY запросов](#в-чем-отличия-eager-от-lazy-запросов)
    * [Что такое индексы? Максимально подробно рассказать про Индексы](#что-такое-индексы-максимально-подробно-рассказать-про-индексы)
    * [Многопоточность](#многопоточность)
    * [Что такое ForkJoinPool](#что-такое-forkjoinpool)
    * [После тестирования обнаружили, что есть утечки памяти. Как вы будете выяснять, утечка ли это? Что с этим делать?](#после-тестирования-обнаружили-что-есть-утечки-памяти-как-вы-будете-выяснять-утечка-ли-это-что-с-этим-делать)
        * [Выявление утечек памяти](#выявление-утечек-памяти)
        * [Устранение утечек памяти](#устранение-утечек-памяти)
    * [Почему могут быть утечки?](#почему-могут-быть-утечки)
    * [Какие метрики вы будете отслеживать? Как они называются?](#какие-метрики-вы-будете-отслеживать-как-они-называются)
    * [Как избежать утечек памяти?](#как-избежать-утечек-памяти)
        * [1. Освобождайте ресурсы](#1-освобождайте-ресурсы)
        * [2. Управление коллекциями](#2-управление-коллекциями)
        * [3. Избегайте статических ссылок](#3-избегайте-статических-ссылок)
        * [4. Проектирование с учетом утечек памяти](#4-проектирование-с-учетом-утечек-памяти)
        * [5. Профилирование и мониторинг](#5-профилирование-и-мониторинг)
        * [6. Обучение и осведомленность](#6-обучение-и-осведомленность)
        * [7. Тестирование](#7-тестирование)
    * [Расскажите, что такое DI?](#расскажите-что-такое-di)
    * [Что значит “управляем спрингом”?](#что-значит-управляем-спрингом)
    * [Что такое Bean](#что-такое-bean)
    * [Жизненный цикл бина](#жизненный-цикл-бина)
        * [1. Инстанцирование](#1-инстанцирование)
        * [2. Заполнение свойств](#2-заполнение-свойств)
        * [3. Вызов методов жизненного цикла](#3-вызов-методов-жизненного-цикла)
        * [4. Post-Processing](#4-post-processing)
        * [5. Готовность к использованию](#5-готовность-к-использованию)
        * [6. Уничтожение](#6-уничтожение)
    * [Способы заинжектить бин](#способы-заинжектить-бин)
        * [1. Внедрение через конструктор (Constructor Injection)](#1-внедрение-через-конструктор-constructor-injection)
        * [2. Внедрение через сеттер (Setter Injection)](#2-внедрение-через-сеттер-setter-injection)
        * [3. Внедрение через поля (Field Injection)](#3-внедрение-через-поля-field-injection)
        * [4. Внедрение через методы (Method Injection)](#4-внедрение-через-методы-method-injection)
        * [5. Внедрение через аннотации `@Resource` и `@Inject`](#5-внедрение-через-аннотации-resource-и-inject)
    * [Какие есть скоупы?](#какие-есть-скоупы)
        * [1. Singleton](#1-singleton)
        * [2. Prototype](#2-prototype)
        * [3. Request](#3-request)
        * [4. Session](#4-session)
        * [5. Application](#5-application)
        * [6. WebSocket](#6-websocket)
    * [Что такое Spring](#что-такое-spring)
    * [Что такое Spring framework?](#что-такое-spring-framework)
    * [В чем отличие Spring Boot от Spring?](#в-чем-отличие-spring-boot-от-spring)
    * [Зачем нужен Spring Boot](#зачем-нужен-spring-boot)
    * [Что использовал из SpringData](#что-использовал-из-springdata)
    * [Что использовал из SpringSecurity](#что-использовал-из-springsecurity)
    * [Максимально глубоко рассказать про устройство SpringCore](#максимально-глубоко-рассказать-про-устройство-springcore)
        * [1. Инверсия управления (IoC) и контейнер IoC](#1-инверсия-управления-ioc-и-контейнер-ioc)
        * [2. Бины](#2-бины)
        * [3. Зависимости](#3-зависимости)
        * [4. Автосвязывание](#4-автосвязывание)
        * [5. Области видимости бинов](#5-области-видимости-бинов)
        * [6. Жизненный цикл бина](#6-жизненный-цикл-бина)
        * [7. Конфигурация](#7-конфигурация)
        * [8. Расширяемость](#8-расширяемость)
        * [9. Интеграция с другими фреймворками](#9-интеграция-с-другими-фреймворками)
    * [Опыт работы с межсервисными протоколами (REST, SOAP, WS, PROTOBUFF, gRPC, graphQL)](#опыт-работы-с-межсервисными-протоколами-rest-soap-ws-protobuff-grpc-graphql)
    * [Опыт работы с модулями спринга](#опыт-работы-с-модулями-спринга)
    * [Опыт работы с AOP](#опыт-работы-с-aop)
    * [Что такое Application Context](#что-такое-application-context)
    * [Что находится в пакете starter и зачем он нужен](#что-находится-в-пакете-starter-и-зачем-он-нужен)
    * [Что такое автоконфигурация](#что-такое-автоконфигурация)
    * [Способы конфигурации спринга](#способы-конфигурации-спринга)
    * [Что такое Синглтон?](#что-такое-синглтон)
    * [чем отличается Синглтон от Прототипа](#чем-отличается-синглтон-от-прототипа)
    * [SOLID](#solid)
    * [Наиболее чаще всего используемые паттерны проектирования](#наиболее-чаще-всего-используемые-паттерны-проектирования)
    * [Где в docker приложении храниться состояния](#где-в-docker-приложении-храниться-состояния)
    * [Как собрать Spring приложение в Docker контейнер](#как-собрать-spring-приложение-в-docker-контейнер)
    * [Как можно вытащить логи из Docker контейнера](#как-можно-вытащить-логи-из-docker-контейнера)
    * [Что произойдет с Kubenetes клайстером если одна нода упадет](#что-произойдет-с-kubenetes-клайстером-если-одна-нода-упадет)
    * [Реактивное программирование](#реактивное-программирование)
    * [Что такое checkstyle](#что-такое-checkstyle)
    * [Что такое SonarQube](#что-такое-sonarqube)
    * [Что такое Mongo](#что-такое-mongo)
    * [Работали с ElasticSearchили и кибана. Что это](#работали-с-elasticsearchили-и-кибана-что-это)
    * [Реактивное программирование](#реактивное-программирование-1)
    * [HealthCheck\HealthBeat](#healthcheckhealthbeat)
    * [В чем суть уязвимости Log4Shell](#в-чем-суть-уязвимости-log4shell)
    * [MSA](#msa)
    * [Service Mash](#service-mash)
* [Git](#git)
* [DataBase](#database)
* [Многопоточность](#многопоточность-1)

<!-- TOC -->

## Java

### Перечислите методы класса Object

* clone
* equals
* finalize (Deprecated)
* getClass
* hashCode
* toString
* notify
* notifyAll
* wait

### Что появилось в Java 11

Удаление JavaFX, Java EE и CORBA. Новый HTTP-клиент: Введен новый HTTP-клиент (java.net.http), который заменяет
устаревший HttpURLConnection. Можно напрямую запускать файлы .java, не компилируя их в .class. Улучшенная интеграция с
Docker

### Чем отличается Set от List

В Java, `Set` и `List` являются интерфейсами, которые наследуются от коллекции `Collection` и представляют собой два
различных способа хранения элементов. Вот основные различия между `Set` и `List`:

1. **Уникальность элементов**:

- `Set` хранит только уникальные элементы. То есть, в коллекции типа `Set` не может быть двух объектов, которые
  считаются равными с точки зрения метода `equals()`.
- `List` может содержать дублирующие элементы. То есть, один и тот же объект может присутствовать в `List` множество
  раз.

2. **Порядок хранения**:

- `List` гарантирует, что элементы будут храниться в порядке их добавления. Это означает, что есть возможность получить
  элемент по его индексу.
- В `Set` порядок хранения элементов не гарантирован. Некоторые реализации `Set`, например `LinkedHashSet`, сохраняют
  порядок добавления элементов, в то время как другие, как `HashSet`, не обеспечивают никакого порядка.

3. **Получение доступа к элементам**:

- В `List` можно легко получить доступ к элементу по его индексу благодаря методу `get(index)`.
- В `Set` нет прямого способа получить доступ к элементу по индексу, так как элементы не индексированы. Доступ к
  элементам обычно осуществляется через итератор.

4. **Производительность**:

- В зависимости от реализации, `Set` может обеспечивать более быстрое выполнение операций добавления, удаления и
  проверки наличия элемента, поскольку многие реализации `Set` используют хэш-таблицы. Например, `HashSet`.
- Для `List` производительность этих операций может быть ниже, особенно когда речь идет о больших объемах данных, так
  как поиск элемента требует перебора списка.

5. **Выбор реализации**:

- Для `Set` есть несколько реализаций, включая `HashSet`, `LinkedHashSet`, и `TreeSet`, каждая из которых имеет свои
  особенности по части порядка элементов и производительности.
- `List` имеет две основные реализации: `ArrayList` и `LinkedList`. `ArrayList` предоставляет быстрый доступ к элементам
  по индексу, в то время как `LinkedList` оптимизирован для операций добавления и удаления.

Как `Set`, так и `List` являются важными инструментами в языке программирования Java, и выбор между ними зависит от
конкретных требований к коллекции в вашем приложении.

### Что использовали для тестов

Для тестирования в Java, особенно в приложениях, разработанных с использованием Spring Framework, используются различные
инструменты и библиотеки. Вот некоторые из них:

1. **JUnit**: Самая популярная библиотека для модульного тестирования в Java. JUnit предоставляет аннотации и классы для
   написания тестов и включает возможности для организации тестовых случаев и генерации отчетов о тестировании. Spring
   поддерживает интеграцию с JUnit для удобства тестирования компонентов Spring.

2. **Mockito**: Фреймворк для создания и использования мок-объектов (объектов-заглушек) в Java. Mockito позволяет
   имитировать поведение классов или интерфейсов для изолированного тестирования компонентов. Это особенно полезно при
   тестировании взаимодействия между компонентами без необходимости создавать сложные зависимости.

3. **Spring Test**: Библиотека, предоставляемая Spring Framework, предлагает обширные возможности для тестирования
   компонентов Spring, включая интеграционные и модульные тесты. Она обеспечивает поддержку загрузки контекста Spring и
   кэширования между тестами, что ускоряет выполнение тестов.

4. **Spring Boot Test**: Часть Spring Boot, предоставляющая удобные аннотации и авто-конфигурацию для тестирования
   приложений Spring Boot. Она включает поддержку тестирования REST-контроллеров, JSON-содержимого, HTML-страниц и
   многое другое.

5. **Hamcrest**: Библиотека для улучшения читаемости кода тестов за счет использования "matcher" выражений. Hamcrest
   позволяет писать более выразительные утверждения в тестах.

Эти инструменты и библиотеки предоставляют мощный набор возможностей для разработки тестов на всех уровнях: от
модульного тестирования до интеграционных и функциональных тестов.

### Что использовали для оптимизации кода

Оптимизация кода в Java и в рамках использования Spring Framework может включать в себя различные подходы и инструменты.
Вот некоторые из наиболее распространенных методов и инструментов для оптимизации:

1. **Профайлинг кода**: Использование профайлеров, например JProfiler, для идентификации узких мест в
   производительности, избыточного использования памяти или утечек памяти.

2. **JMH (Java Microbenchmark Harness)**: Официальный инструмент для создания, запуска и анализа микробенчмарков,
   разработанный группой разработки JDK. Это особенно полезно для точной оценки производительности отдельных блоков
   кода.

4. **Checkstyle, PMD, SonarQube**: Инструменты для статического анализа кода, которые помогают обнаружить проблемы с
   качеством кода, потенциальные узкие места, неэффективные конструкции и нарушения стилевых гайдлайнов.

5. **Spring Boot Actuator**: Для приложений на Spring Boot, Actuator предоставляет встроенные конечные точки для
   мониторинга и управления приложением, включая метрики производительности, состояние бина, здоровье приложения и
   другие.

6. **Кэширование**: Использование Spring Cache или других библиотек кэширования, таких как EhCache или Hazelcast, для
   сокращения времени отклика приложения путем хранения результатов дорогостоящих операций.

7. **Оптимизация запросов к базе данных**: Использование JPA/Hibernate профилировщиков или логирования SQL для
   оптимизации запросов к базе данных, устранения N+1 проблемы запросов и улучшения производительности операций с базой
   данных.

### Что такое мутабельность и иммутабельность

### У нас есть класс “джава ланг стринг”. Как он устроен?

[Как устроен String](string_pool_in_java.md)

### Что такое “внутренние библиотеки”?

В Java "внутренние библиотеки" относятся к стандартной библиотеке Java (Java Standard Library), которая также известна
как Java API (Application Programming Interface). Эти библиотеки предоставляют разработчикам набор предопределенных
классов и интерфейсов для выполнения различных задач, таких как ввод-вывод данных, управление сетевыми соединениями,
разработка графического пользовательского интерфейса, обработка дат и времени, и многое другое.

Стандартная библиотека Java является частью Java Development Kit (JDK) и автоматически доступна при разработке
приложений на Java. Она организована в пакеты, каждый из которых предназначен для определенной области задач. Например:

- `java.lang`: содержит классы, которые являются фундаментальными для языка программирования Java, такие
  как `String`, `Math`, `System`, и классы оболочки для примитивных типов данных.
- `java.util`: предлагает классы и интерфейсы для работы с коллекциями данных (например, списками, множествами,
  картами), а также для выполнения различных вспомогательных функций, таких как генерация случайных чисел, дата и время.
- `java.io`: предоставляет классы для чтения и записи данных (ввода-вывода), включая работу с файлами.
- `java.net`: содержит классы для работы с сетью, включая выполнение HTTP запросов и работы с URL.

Эти и другие пакеты в стандартной библиотеке Java позволяют разработчикам быстро создавать мощные и эффективные
приложения, не заботясь о низкоуровневой реализации многих стандартных функций.

### Помимо индексов сталкивались с балансированием деревьев?

### В узлах деревьев должны быть имутабельные объекты, что это такое?

### У вас возникла задача разработать неизменяемый объект, который вы будете применять в деревьях. Как вы будете его разрабатывать?

### Как вы оцениваете трудоемкость реализации на бекэнде?

Оценка трудоемкости реализации на бекэнде зависит от многих факторов, таких как сложность проекта, требования к
производительности и безопасности, использование технологий и инструментов, а также опыт и навыки команды разработчиков.
Вот несколько ключевых аспектов, которые стоит учитывать при оценке трудоемкости:

#### 1. Требования к проекту

- **Сложность функционала**: Более сложные задачи требуют больше времени и ресурсов.
- **Интеграция с внешними системами**: Интеграция с API, сторонними сервисами или сложными базами данных может увеличить
  трудоемкость.
- **Требования к безопасности**: Реализация мер безопасности, таких как шифрование данных, аутентификация и авторизация
  пользователей, требует дополнительных ресурсов.
- **Масштабируемость**: Проектирование системы с учетом будущего роста и нагрузки может потребовать дополнительных
  усилий.

#### 2. Технологический стек

- **Выбор языка программирования и фреймворков**: Некоторые языки и фреймворки могут ускорить разработку за счет готовых
  решений и библиотек.
- **Использование готовых решений и библиотек**: Использование готовых компонентов может существенно сократить время
  разработки.

#### 3. Команда

- **Опыт и навыки команды**: Опытные разработчики могут быстрее справиться с задачами и находить более эффективные
  решения.
- **Размер команды**: Большая команда может выполнять задачи быстрее, но также требуется время на координацию и
  коммуникацию.

#### 4. Процесс разработки

- **Методология разработки**: Гибкие методологии, такие как Agile, могут ускорить разработку за счет итеративного
  подхода и постоянной обратной связи.
- **Тестирование**: Включение автоматизированных тестов и непрерывной интеграции может увеличить начальную трудоемкость,
  но сократить время на поиск и исправление ошибок в долгосрочной перспективе.

#### 5. Управление проектом

- **Планирование и отслеживание**: Тщательное планирование и регулярное отслеживание прогресса помогает избежать
  задержек и перерасхода ресурсов.

Оценка трудоемкости — это сложный процесс, требующий учета множества переменных. Часто используются методы экспертных
оценок, такие как Planning Poker, или формализованные подходы, например, Function Point Analysis, чтобы сделать оценку
более объективной и точной.

### Что такое Lambda?

Lambda (или лямбда-выражение) в Java — это способ предоставления реализации интерфейса с одним абстрактным методом (
также известного как функциональный интерфейс) в компактной форме. Лямбда-выражения были добавлены в Java 8 и
представляют собой одну из ключевых особенностей, позволяющих писать более краткий и читаемый код, особенно когда речь
идет о работе с коллекциями или потоками данных.

### Что такое функциональный интерфейс?

Функциональный интерфейс в Java — это интерфейс, который содержит только один абстрактный метод.

### Сигнатуры функций?

Сигнатура функции (или метода) в программировании — это определение, которое включает имя функции, количество и типы
параметров и тип возвращаемого значения. Сигнатура функции не включает тело функции (то есть конкретные инструкции
функции) и часто используется для определения интерфейса, которому должны соответствовать различные реализации функции.

### Максимально глубоко рассказать про HashMap

### Можно ли в HashMap использовать null в качестве ключа

### Можно ли в ConcurrentMap использовать null в качестве ключа

Нет, в `ConcurrentMap` в Java нельзя использовать `null` ни в качестве ключа, ни в качестве значения. Попытка
вставить `null` в `ConcurrentMap` (как `ConcurrentHashMap`, так и любые другие реализации этого интерфейса) приведет к
выбросу исключения `NullPointerException`. Это ограничение обусловлено потребностью в обеспечении атомарности операций и
предотвращении проблем синхронизации, так как `null` значения могут вызвать двусмысленность в логике синхронизации и
состоянии коллекции.

### В каком тайме упадет IllegalStateException (Compile или Runtime)

`IllegalStateException` является исключением времени выполнения (runtime exception) в Java. Это непроверяемое
исключение, которое может быть выброшено, чтобы указать на то, что метод был вызван в неподходящее время, или же
состояние объекта не позволяет выполнить запрашиваемую операцию. Поскольку это исключение происходит во время выполнения
программы, оно не требует обработки с помощью блоков `try-catch` или указания в сигнатуре метода с помощью `throws`,
хотя это и может быть сделано для улучшения качества кода.

### Что будет в результате Stream.of(“1”,”2”,”3”,”4”).filter(v ->v.equals(“1”))

### Что такое Stream API?

Stream API в Java — это набор классов и интерфейсов в пакете `java.util.stream`, который представляет собой
высокоуровневую абстракцию для обработки последовательностей элементов. Этот API был введён в Java 8 и позволяет
описывать сложные операции над данными в виде высокоуровневых конструкций, используя концепции функционального
программирования.

Stream API предоставляет два вида операций:

1. **Промежуточные операции (Intermediate operations)** — такие операции возвращают новый поток, и поэтому они могут
   быть соединены в цепочки (они «ленивые» и не выполняются до тех пор, пока не будет вызвана терминальная операция).
   Примеры включают `filter`, `map`, `sorted`.

2. **Терминальные операции (Terminal operations)** — такие операции завершают поток и выдают результат. Такие операции,
   как `forEach`, `collect`, `reduce`, `findFirst`.

Stream API имеет несколько преимуществ:

- **Выразительность**: Часто можно описать сложную обработку данных в несколько строк кода.
- **Легко читаемый код**: Операции Stream часто являются более читаемыми и компактными, чем традиционные конструкции,
  такие как циклы.
- **Поддержка функционального стиля программирования**: Stream API делает простым использование функций высшего порядка
  для операций над данными.
- **Ленивые вычисления**: Промежуточные операции не выполняют никаких вычислений, пока не будет вызвана терминальная
  операция.
- **Параллелизм**: Стримы могут быть легко выполнены параллельно для улучшения производительности без необходимости
  изменения кода, если данные не имеют состояния и операции являются независимыми.

### Что такое функции высшего порядка?

Функции высшего порядка — это функции, которые могут принимать другие функции в качестве параметров или возвращать
функции как результат своей работы. Это позволяет программистам создавать более абстрактные уровни операций, где функции
используются как значения. Это ключевой аспект функционального программирования.

### Что такое InputStream и OutputStream и как они связаны со Stream API?

`InputStream` и `OutputStream` в Java — это абстрактные классы, представляющие потоки ввода и вывода данных
соответственно. Они являются частью пакета `java.io` и используются для чтения и записи байтов (для `InputStream`) или
для записи байтов (для `OutputStream`), и это может быть файл, сетевое соединение, память и т.д.

- **InputStream** предоставляет общий интерфейс для чтения байтовых данных. Например, метод `read()` читает следующий
  байт данных из потока.
- **OutputStream** предоставляет общий интерфейс для записи байтовых данных. Например, метод `write(int b)` записывает
  указанный байт в поток.

Эти потоки являются блокирующими и ориентированы на работу с байтами, что отличается от работы с потоками
в `java.util.stream`, которые представляют потоки объектов и используются для работы с последовательностями данных,
поддерживая функциональные операции.

Stream API в Java, представленный в Java 8, это совершенно другая концепция и относится к потокам
объектов (`java.util.stream`), а не байтов. Stream API предоставляет механизмы для обработки коллекций объектов с
использованием функциональных операций, таких как `map`, `filter`, `reduce`. Потоки Stream API поддерживают как
последовательные, так и параллельные операции и являются основой для функционального стиля программирования в Java.

Хотя `InputStream`/`OutputStream` и Stream API оба используют термин «stream», они предназначены для разных целей и
работают с разными типами данных. `InputStream`/`OutputStream` — для байтов и бинарных данных, а Stream API — для
объектов и операций над ними на высоком уровне абстракции.

### Что вы вкладываете в слово поток?

Слово "поток" в контексте программирования чаще всего относится к последовательности элементов, обрабатываемых в
определенной последовательности.

### Что такое потоковый режим?

Потоковый режим или потоковая передача данных — это способ обработки или передачи данных, при котором они передаются и
обрабатываются последовательно, часто без знания общего объема данных. Это противоположность пакетной обработке, где
обработка начинается только после получения всех доступных данных.

### В каких операциях нужно два элемента?

В программировании существует несколько операций, для которых требуются два элемента. Вот несколько примеров:

1. **Арифметические операции**: Сложение (+), вычитание (-), умножение (*), деление (/), остаток от деления (%). Каждая
   из этих операций принимает два операнда. Например, `a + b` или `x / y`.

2. **Логические операции**: Логическое И (&&), логическое ИЛИ (||). Эти операции используются для соединения двух
   булевых выражений. Например, `expression1 && expression2`.

3. **Битовые операции**: Битовое И (&), битовое ИЛИ (|), исключающее ИЛИ (^), сдвиг влево (<<), сдвиг вправо (>>). Эти
   операции выполняются над двумя числовыми значениями. Например, `number1 & number2`.

4. **Сравнения**: Равенство (==), неравенство (!=), меньше (<), больше (>), меньше или равно (<=), больше или
   равно (>=). Эти операторы сравнивают два значения. Например, `a < b`.

5. **Операции с коллекциями**: Например, `Map.put(key, value)` требует ключ и значение для сохранения в карте.

6. **Функциональные интерфейсы**: Некоторые функциональные интерфейсы в Java, такие как `BiFunction<T, U, R>`
   или `BiPredicate<T, U>`, определены для принятия двух аргументов.

7. **Методы с двумя параметрами**: Методы, требующие двух параметров для выполнения. Например, `Math.max(a, b)` для
   нахождения максимального из двух значений.

8. **Конструкторы**: Некоторые конструкторы объектов требуют двух параметров для инициализации объекта.
   Например, `Point(x, y)` может требовать координаты x и y.

9. **Терминальные операции в Stream API**: Операция `reduce` принимает два параметра — начальное значение и функцию,
   которая будет применяться к элементам потока.

10. **Лямбда выражения и методы**: В лямбда выражениях или методах могут быть использованы два параметра.
    Например, `(x, y) -> x + y` или `void compare(String a, String b)`.

### Операции в Stream API, они как-то отличаются друг от друга? Разновидности?

Stream API предоставляет два вида операций:

1. **Промежуточные операции (Intermediate operations)** — такие операции возвращают новый поток, и поэтому они могут
   быть соединены в цепочки (они «ленивые» и не выполняются до тех пор, пока не будет вызвана терминальная операция).
   Примеры включают `filter`, `map`, `sorted`.

2. **Терминальные операции (Terminal operations)** — такие операции завершают поток и выдают результат. Такие операции,
   как `forEach`, `collect`, `reduce`, `findFirst`.

### Как работают стримы под капотом

Под капотом стримы в Java работают на основе нескольких ключевых принципов и компонентов:

1. **Пайплайнинг (Pipelining)**: Операции со стримами формируют "пайплайн" — цепочку операций, которая применяется
   последовательно. Промежуточные операции обрабатывают данные и передают их дальше по цепочке, не производя обработку
   всех данных сразу.

2. **Ленивость (Laziness)**: Промежуточные операции являются ленивыми, то есть они не выполняются до тех пор, пока не
   будет вызвана терминальная операция. Это позволяет избежать лишней работы, например, при использовании
   операций `limit` или `findFirst`.

3. **Внутренние итерации (Internal Iterations)**: В отличие от внешних итераций с помощью циклов, стримы используют
   внутренние итерации, скрывая детали обхода элементов, что упрощает многопоточное выполнение.

4. **Неизменяемость (Immutability)**: Стримы не изменяют исходные данные. Вместо этого они, как правило, возвращают
   новые стримы с результатами промежуточных операций.

5. **Параллелизм (Parallelism)**: Стримы могут быть выполнены параллельно с помощью метода `parallel`, который разбивает
   данные на части, обрабатывает их в разных потоках и затем собирает результаты.

6. **Функциональные интерфейсы (Functional Interfaces)**: Стримы тесно связаны с функциональными
   интерфейсами (`Predicate`, `Function`, `Consumer` и т. д.), которые предоставляют методы для выполнения операций над
   элементами.

7. **Сплитераторы (Spliterators)**: Для работы с параллельными стримами используются сплитераторы, которые разделяют
   данные на части для параллельной обработки. Сплитераторы определяют, как данные будут разделены и в какой
   последовательности будут обрабатываться элементы.

8. **Коллекторы (Collectors)**: Для сбора данных из стримов в коллекции или другие структуры данных используются
   коллекторы, предоставляемые классом `Collectors`.

9. **Оптимизация**: Некоторые операции стримов могут быть оптимизированы под капотом. Например, `map` и `filter` могут
   быть объединены в одну операцию, чтобы минимизировать проходы по данным.

10. **Состояние**: Некоторые промежуточные операции, такие как `distinct` и `sorted`, требуют сохранения состояния (
    запоминания элементов, которые уже были обработаны).

Сама модель стримов — это больше о паттерне проектирования, который позволяет разработчикам использовать функциональные
стили программирования в Java, абстрагируя многие сложные аспекты обработки данных, такие как параллелизм и оптимизация
итераций.

### Можно ли вызвать дважды у одного стрима терминирующий метод

Нет, терминирующий метод у одного и того же стрима вызвать дважды нельзя. После вызова терминальной операции поток
считается «исчерпанным» или «закрытым», и любая попытка использовать его снова приведет к `IllegalStateException`. Если
вам нужно выполнить несколько терминальных операций с одинаковыми данными, вам следует создать новый поток для каждой
операции.

### Как посмотреть все ветки в git

git branch -a

### Как посмотреть все удаленные репы в git

Чтобы посмотреть все удалённые репозитории, к которым ваш локальный Git репозиторий имеет доступ, можно использовать
команду `git remote -v`. Эта команда выведет список всех удалённых подключений, включая URL для операций fetch и push
для каждого удалённого репозитория.

Если вам нужно увидеть удалённые ветки, сначала выполните `git fetch --prune`. Опция `--prune` удалит ссылки на
удалённое отслеживание, которые больше не существуют в удалённом репозитории. Затем командой `git branch -r` вы можете
просмотреть все удалённые ветки; удалённые ветки в списке уже не будут отображаться.

### Что такое git flow

Git Flow — это модель ветвления для Git, предложенная Винсентом Дриессеном в 2010 году. Она определяет
стандартизированный набор веток и правил их использования, что облегчает управление версиями и разработку в командах. В
Git Flow выделяют следующие типы веток:

1. **Основные ветки:**
    - `master`: стабильная ветка, содержащая код, готовый к релизу в продакшен.
    - `develop`: основная ветка для разработки, все новые фичи сначала попадают сюда.

2. **Вспомогательные ветки:**
    - `feature`: ветки для разработки новых функций, создаются от `develop` и вливаются обратно в `develop`.
    - `release`: ветки для подготовки релизов, они позволяют финализировать релиз и устранять ошибки перед тем, как код
      попадёт в `master`.
    - `hotfix`: ветки для срочного исправления ошибок в коде, который уже находится в продакшене. Создаются от `master`
      и вливаются в `master` и `develop`.

Помимо структуры веток, Git Flow предполагает конкретный рабочий процесс:

- Новые фичи разрабатываются в соответствующих ветках `feature/`, которые потом сливаются с `develop`.
- Когда разработка фичей для следующего релиза завершена, создаётся ветка `release/`, где происходит финальная
  подготовка к выпуску версии.
- После проверки и готовности, ветка `release` сливается в `master` и помечается тегом с номером версии.
- Если в продакшене обнаруживается баг, создаётся `hotfix/`, который после исправления вливается обратно в `master`
  и `develop`.

Git Flow хорошо подходит для проектов, где чётко определены стадии разработки и выпуска версий, а также важен строгий
контроль за стабильностью продакшен-версии.

### Работали ли вы с базами данных?

### С какими базами работали

### Какие не реляционные СУБД использовал (IN-Memory в т.ч.)

Вот некоторые из них:

1. **Документо-ориентированные базы данных**:
    - **MongoDB**: хранит данные в формате BSON, похожем на JSON.

2. **Ключ-значение хранилища**:
    - **Redis**: in-memory хранилище, часто используется как кэш или для хранения сессий.

5. **Поисковые системы**:
    - **Elasticsearch**: не только база данных, но и поисковая система и аналитическая платформа.

6. **Базы данных для мобильных приложений**:
    - **Firebase Realtime Database**: база данных в реальном времени от Google.
    - **Realm**: легковесная и быстрая база данных, оптимизированная для мобильных устройств.

Каждая из этих систем предлагает свои особенности и преимущества, в зависимости от требований к производительности,
удобству масштабирования, типа хранимых данных и сложности запросов. In-memory базы данных, такие как Redis, обычно
используются для задач, требующих высокой скорости доступа к данным.

### Отличия реляционных и нереляционных

Реляционные (SQL) и нереляционные (NoSQL) системы управления базами данных (СУБД) имеют ряд ключевых отличий:

**1. Схема данных:**

- **Реляционные СУБД**: Имеют строгую схему с таблицами, строки которых содержат данные, а столбцы — атрибуты. Все
  данные должны соответствовать схеме, что требует планирования перед вставкой данных.
- **Нереляционные СУБД**: Гибкие в отношении схемы данных. Могут хранить документо-ориентированные данные,
  ключ-значение, графы и широкостолбцовые хранилища. Не требуют заранее определенной схемы, и структура данных может
  изменяться "на лету".

**2. Запросы:**

- **Реляционные СУБД**: Используют язык SQL для создания, чтения, обновления и удаления данных (CRUD операции), который
  является мощным и стандартизированным средством запросов.
- **Нереляционные СУБД**: Используют разнообразные способы запросов, которые зависят от типа СУБД, включая RESTful API,
  специфичные для базы данных языки запросов или даже использование кода (например, JavaScript).

**3. Транзакции:**

- **Реляционные СУБД**: Обычно поддерживают многошаговые транзакции и обеспечивают свойства ACID (атомарность,
  согласованность, изолированность, долговечность), что критично для приложений, где необходима строгая консистентность
  данных.
- **Нереляционные СУБД**: Некоторые поддерживают транзакции, но они могут быть ограничены или работать по-другому. В
  целом, NoSQL СУБД склонны к обеспечению свойств BASE (базовая доступность, мягкая состояние, конечная
  согласованность), что подразумевает более легкую консистентность для обеспечения лучшей доступности и разделения.

**4. Масштабируемость:**

- **Реляционные СУБД**: Традиционно оптимизированы для вертикального масштабирования, что означает улучшение аппаратных
  характеристик сервера.
- **Нереляционные СУБД**: Часто разработаны с учетом горизонтального масштабирования, распределения данных по множеству
  серверов, что делает их более гибкими в управлении большими объемами данных.

**5. Работа с данными:**

- **Реляционные СУБД**: Идеально подходят для сложных запросов и операций, требующих точной связи между таблицами
  данных.
- **Нереляционные СУБД**: Лучше подходят для сценариев, где необходима быстрая запись/чтение операций и где связи между
  данными менее структурированы или не так важны.

Выбор между реляционной и нереляционной СУБД зависит от требований конкретного приложения, требуемой производительности,
гибкости, масштабируемости и

### Как работать с реляционными базами данных?

### Что такое транзакции в базах данных?

### Что значит “данные остаются консистентными и согласованными”?

Когда говорят, что "данные остаются консистентными и согласованными", это означает, что они сохраняют целостность и
точность в течение всего времени их жизни в базе данных или системе. В контексте управления данными, консистентность и
согласованность относятся к нескольким важным аспектам:

1. **Консистентность**: Данные считаются консистентными, если они соответствуют определённым правилам и ограничениям.
   Например, в реляционной базе данных, консистентность данных может быть обеспечена с помощью ограничений целостности,
   таких как внешние ключи, правила проверки (check constraints) и триггеры. Консистентность обеспечивает, что любые
   операции с данными (вставка, обновление, удаление) не нарушат эти ограничения.

2. **Согласованность**: Согласованность данных означает, что данные в разных частях системы не противоречат друг другу и
   обновляются синхронно. Например, если одна часть системы обновляет данные, другие части должны отражать это
   обновление и не содержать старых или устаревших значений.

В контексте транзакций и баз данных, эти понятия часть свойств ACID:

- **Atomicity (Атомарность)**: транзакция выполняется полностью или не выполняется вообще.
- **Consistency (Консистентность)**: транзакция не нарушит никаких правил или ограничений базы данных и после её
  выполнения база данных будет в консистентном состоянии.
- **Isolation (Изоляция)**: транзакции выполняются независимо друг от друга.
- **Durability (Долговечность)**: после завершения транзакции, её результаты сохраняются и не могут быть потеряны.

Таким образом, обеспечение консистентности и согласованности в данных — критический аспект управления данными, который
помогает поддерживать порядок, предотвращать ошибки и упрощать анализ и отчётность.

### Как сделать так, чтобы к окончанию транзакции мы точно знали, что всё посчитается корректно, посчитаются даже параллельные транзакции?

Для гарантии корректности вычислений в конце транзакции, а также учета параллельно выполняемых транзакций, СУБД
используют механизмы, обеспечивающие ACID свойства. Вот как это обычно достигается:

1. **Атомарность (Atomicity)**: СУБД гарантируют, что каждая транзакция либо выполняется полностью, либо не выполняется
   вовсе. Это достигается через механизмы, такие как журналирование транзакций, которые позволяют восстановить
   предыдущее состояние в случае ошибки.

2. **Консистентность (Consistency)**: Ограничения целостности данных (например, внешние ключи, ограничения уникальности)
   помогают обеспечить, что данные останутся консистентными после каждой транзакции. СУБД не допустят завершения
   транзакции, если она нарушает эти ограничения.

3. **Изоляция (Isolation)**: Уровни изоляции транзакций контролируют, как и когда результаты выполнения одной транзакции
   становятся видимыми для других транзакций. Строгая изоляция может защитить от проблем, таких как "грязное чтение" (
   dirty reads), "неповторяющееся чтение" (non-repeatable reads) и "фантомное чтение" (phantom reads). В системах, где
   требуется высокая производительность и допустимо некоторое ослабление строгости, могут использоваться более слабые
   уровни изоляции.

4. **Долговечность (Durability)**: После подтверждения транзакции, СУБД гарантируют, что её результаты сохранятся, даже
   в случае сбоя системы. Это достигается через механизмы вроде записи в журнал транзакций и точек сохранения (
   checkpoints).

Для обработки параллельных транзакций и обеспечения консистентности, СУБД могут использовать различные стратегии, такие
как:

- **Блокировки (Locking)**: СУБД могут применять блокировки к ресурсам (строкам, страницам, таблицам), чтобы
  контролировать доступ и предотвратить конфликты между транзакциями.
- **Оптимистичное управление параллелизмом**: Подразумевает проверку на конфликты в конце транзакции и откат, если
  таковые обнаружены.
- **Многоверсионное управление параллелизмом (MVCC)**: Каждая транзакция работает с "снимком" данных, что позволяет
  избежать блокировок при чтении и улучшить параллелизм.

Выбор стратегии и настройка уровней изоляции транзакций зависят от конкретных требований приложения к производительности
и консистентности данных. В идеале, разработчики и администраторы баз данных должны стремиться к балансу между строгой
изоляцией транзакций для точности и гибкостью для эффективной параллельной работы.

### Что такое “оптимистичная блокировка”?

Оптимистичная блокировка — это стратегия управления параллелизмом в системах управления базами данных, которая
предполагает, что конфликты при доступе к данным возникают редко, и что лучше позволить транзакциям выполняться без
блокировок, предполагая минимальный риск конфликта. Вместо того чтобы удерживать блокировки на данные в течение всей
транзакции, система с оптимистичной блокировкой отслеживает изменения и, при попытке подтвердить транзакцию, проверяет
наличие конфликтов. Если конфликтов нет, транзакция завершается успешно. Если же конфликты обнаружены, транзакция
откатывается.

Пример работы оптимистичной блокировки:

1. **Начало транзакции**: Вы начинаете транзакцию и читаете некоторые данные.

2. **Выполнение работы**: Вы выполняете работу в приложении, возможно, изменяя данные, но не устанавливаете блокировку
   на них в базе данных.

3. **Подтверждение транзакции**: При попытке подтвердить транзакцию система проверит, не были ли изменены данные с
   момента их первого чтения. Это обычно делается путем проверки маркеров версий (версионирование данных) или хешей.

4. **Обработка конфликтов**: Если данные не изменились, транзакция подтверждается. Если данные изменились другой
   транзакцией, текущая транзакция откатывается, и, возможно, повторяется попытка.

Оптимистичная блокировка подходит для сред, где блокировка или транзакции на длительное время могут негативно сказаться
на производительности системы из-за низкой вероятности конфликтов. Напротив, пессимистичная блокировка (где блокировки
удерживаются на протяжении всей транзакции) больше подходит для систем, где конфликты более вероятны.

### Что такое “пессимистичная блокировка”? Как это реализуетя в коде?

### Как происходила доставка схемы до базы данных?

### Что такое ОРМ?

### Что такое JDBC

### Что такое JPA

### Что такое реляция?

### Criteria API

### Что делает Explain

### Что такое репликация и шардирование

### Работы с транзакциями в Hibernate

### Кеширование в Hibernate

### Управление схемами данных

### Отличие Inner Join от Left Join

В SQL, `INNER JOIN` и `LEFT JOIN` (также известный как `LEFT OUTER JOIN`) — это два типа операций объединения таблиц,
которые позволяют получать данные из двух или более таблиц на основе связей между ними. Важно понимать разницу между
этими двумя типами объединения, чтобы правильно использовать их в запросах.

#### INNER JOIN

`INNER JOIN` возвращает строки, когда есть хотя бы одно совпадение в обеих таблицах. Если строка в одной таблице не
имеет соответствия в другой, она не включается в результаты. Это означает, что `INNER JOIN` возвращает только те строки,
которые имеют совпадающие значения в обеих таблицах.

Пример:

```sql
SELECT Orders.OrderID, Customers.CustomerName
FROM Orders
         INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
```

В этом примере возвращаются только заказы, для которых есть соответствующие клиенты.

#### LEFT JOIN (LEFT OUTER JOIN)

`LEFT JOIN` возвращает все строки из левой таблицы (таблицы, которая находится перед `JOIN`), а совпадающие строки из
правой таблицы (таблицы после `JOIN`). Если в правой таблице нет совпадения, вместо значений из правой таблицы
возвращаются `NULL`.

Пример:

```sql
SELECT Orders.OrderID, Customers.CustomerName
FROM Orders
         LEFT JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
```

В этом примере возвращаются все заказы, включая те, для которых нет соответствующих клиентов (в этих
случаях `CustomerName` будет `NULL`).

#### Основные различия

- **Набор возвращаемых строк**: `INNER JOIN` возвращает только совпадающие строки, тогда как `LEFT JOIN` возвращает все
  строки из левой таблицы, дополняя их данными из правой таблицы, когда возможно.
- **Использование**: Используйте `INNER JOIN`, когда вам нужны строки, которые имеют совпадения в обеих таблицах.
  Используйте `LEFT JOIN`, когда вам нужно сохранить все строки из левой таблицы, даже если нет совпадений в правой
  таблице.

Выбор между `INNER JOIN` и `LEFT JOIN` зависит от того

### Отличие Join от Union

`JOIN` и `UNION` в SQL служат разным целям и используются для решения различных задач при работе с данными.

#### JOIN

`JOIN` используется для объединения строк из двух или более таблиц, основываясь на связанном столбце между ними.
Существует несколько типов `JOIN`:

- **INNER JOIN**: возвращает строки, когда существует по крайней мере одно совпадение в обеих таблицах.
- **LEFT JOIN** (или LEFT OUTER JOIN): возвращает все строки из левой таблицы и совпадающие строки из правой таблицы.
  Если совпадений нет, результат содержит `NULL` с правой стороны.
- **RIGHT JOIN** (или RIGHT OUTER JOIN) и **FULL JOIN** (или FULL OUTER JOIN) работают аналогично, но сосредотачиваются
  на правой таблице и обеих таблицах соответственно.

`JOIN` обычно используется, когда вам нужно извлечь данные, которые находятся в разных таблицах и имеют логическую
связь, и представить их в одном результате.

Пример:

```sql
SELECT Orders.OrderID, Customers.CustomerName
FROM Orders
         INNER JOIN Customers ON Orders.CustomerID = Customers.CustomerID;
```

#### UNION

`UNION` используется для объединения результатов двух или более `SELECT` запросов в один набор результатов, включая
только уникальные строки. Все `SELECT` запросы в `UNION` должны иметь одинаковое количество столбцов в результате, с
совместимыми типами данных.

- **UNION**: возвращает только уникальные строки из всех запросов.
- **UNION ALL**: возвращает все строки (включая дубликаты) из всех запросов.

`UNION` используется, когда необходимо объединить данные из разных запросов, таблиц или даже из разных баз данных в один
набор результатов.

Пример:

```sql
SELECT CustomerName
FROM Customers
UNION
SELECT VendorName
FROM Vendors;
```

#### Основные отличия

- **Цель использования**: `JOIN` объединяет строки из различных таблиц по связанному столбцу, в то время как `UNION`
  объединяет результаты двух или более запросов в один набор результатов.
- **Результаты**: `JOIN` создает результаты, основанные на столбцах из объединяемых таблиц. `UNION` объединяет строки из
  разных запросов в единый набор строк.
- **Уникальность**: По умолчанию, `UNION` удаляет дубликаты из результата, тогда как `JOIN` не изменяет уникальность
  строк в объединенных таблицах. `UNION ALL` сохраняет все строки, включая дубликаты.

Выбор между `JOIN` и `UNION` зависит от вашей конкретной задачи: необходимо ли вам объединить данные из разных таблиц на
основе общего ключа (используйте `JOIN`) или же собрать данные из различных запросов в один набор строк (
используйте `UNION` или `UNION ALL`).

### Как работает индексация

### В чем отличия EAGER от LAZY запросов

### Что такое индексы? Максимально подробно рассказать про Индексы

### Многопоточность

### Что такое ForkJoinPool

### После тестирования обнаружили, что есть утечки памяти. Как вы будете выяснять, утечка ли это? Что с этим делать?

Утечка памяти в Java может быть довольно сложной для выявления и устранения, потому что сборщик мусора автоматически
управляет памятью. Однако даже в такой среде утечки могут происходить, особенно если объекты, которые больше не нужны,
по-прежнему доступны через ссылки из доступных областей памяти.

#### Выявление утечек памяти

1. **Используйте профилировщики памяти**: Инструменты, такие как VisualVM, JProfiler, или YourKit, позволяют наблюдать
   за потреблением памяти вашего приложения в реальном времени, выявлять объекты, которые занимают больше всего памяти,
   и определять, какие из них не освобождаются.

2. **Анализ дампов памяти**: При подозрении на утечку вы можете создать дамп памяти (heap dump) с помощью инструментов,
   таких как `jmap`, или автоматически при возникновении `OutOfMemoryError`, если установлен соответствующий флаг
   JVM (`-XX:+HeapDumpOnOutOfMemoryError`). Затем анализируйте дамп с помощью Eclipse Memory Analyzer (MAT) или других
   аналогичных инструментов, чтобы найти объекты, которые занимают большую часть памяти и пути их достижения, что
   поможет определить причину утечки.

3. **Проверьте статические поля**: Объекты, на которые ссылаются статические поля, остаются в памяти на протяжении всего
   времени работы приложения. Если такие объекты динамически накапливают ссылки на другие объекты, это может привести к
   утечкам.

4. **Внимательно отнеситесь к коллекциям**: Неправильное использование коллекций (например, HashMap, ArrayList) может
   привести к утечкам памяти, если из коллекций не удаляются объекты.

5. **Проверьте использование внешних ресурсов**: Утечки также могут происходить из-за неправильного управления
   ресурсами, такими как соединения с базой данных, файловые дескрипторы или потоки.

#### Устранение утечек памяти

- **Исправление кода**: Как только вы идентифицируете проблемные области с помощью профилировщиков или анализа дампов
  памяти, вам нужно изменить код таким образом, чтобы устранить утечки. Это может включать в себя удаление лишних ссылок
  на объекты, правильное закрытие ресурсов в блоках `finally` или использование конструкций `try-with-resources`.

- **Оптимизация использования коллекций**: Убедитесь, что объекты удаляются из коллекций, когда они больше не нужны.

- **Использование слабых ссылок**: В некоторых случаях использование слабых ссылок (`WeakReference`) может помочь.
  Объекты, на которые ссылаются только слабые ссылки, могут быть собраны сборщиком мусора, даже если ссылки еще
  существуют.

- **Проведение регрессионного тестирования**: После внесения изменений в код, проведите регрессионное тестирование,
  чтобы убедить

### Почему могут быть утечки?

Утечки памяти в Java и других языках программирования могут возникать по множеству причин. В контексте управляемой
среды, такой как Java, где сборщик мусора автоматически управляет выделением и освобождением памяти, утечки памяти
обычно происходят, когда объекты, которые больше не нужны приложению, по-прежнему удерживаются в памяти из-за
существующих ссылок на них. Вот некоторые конкретные причины, по которым могут возникать утечки памяти:

1. **Неправильное управление коллекциями**: Объекты могут быть добавлены в коллекцию и никогда не удаляться, даже когда
   они больше не используются. Это особенно верно для статических коллекций, которые остаются в памяти в течение всего
   срока службы приложения.

2. **Статические поля**: Если статическое поле ссылается на объект, эта ссылка остается активной в течение всего времени
   работы приложения, что может привести к утечке памяти, если объект больше не нужен, но все еще доступен через
   статическую ссылку.

3. **Наблюдатели и обратные вызовы**: Подписка на события или регистрация обратных вызовов без соответствующей отписки
   может привести к утечкам памяти, поскольку объекты обработчиков событий могут быть удерживаемы дольше, чем
   необходимо.

4. **Закрытие ресурсов**: Неудачное или отсутствующее закрытие ресурсов, таких как потоки ввода-вывода, соединения с
   базой данных или файловые дескрипторы, может привести к утечке ресурсов, что иногда называют "утечкой ресурсов", хотя
   это и отличается от утечек памяти.

5. **Кэширование без стратегии истечения срока действия**: Кэширование объектов без политики очистки или истечения срока
   действия может привести к накоплению неиспользуемых объектов в памяти.

6. **Неправильное использование сторонних библиотек**: Иногда утечки памяти могут быть вызваны ошибками или недостатками
   в сторонних библиотеках, которые использует ваше приложение.

7. **Потоки**: Незавершенные или "зомби" потоки, которые продолжают выполняться после того, как они должны были быть
   завершены, могут удерживать объекты в памяти, предотвращая их сбор.

8. **Паттерны проектирования**: Некоторые паттерны проектирования, если они используются неправильно, могут
   способствовать утечкам памяти. Например, Singleton или Observer могут удерживать ссылки на объекты дольше, чем
   требуется.

Решение этих проблем требует тщательного анализа и профилирования приложения, а также осознанного использования ресурсов
и ссылок в вашем коде.

### Какие метрики вы будете отслеживать? Как они называются?

При диагностике утечек памяти и мониторинге производительности Java-приложений важно отслеживать ряд ключевых метрик,
которые помогут выявить потенциальные проблемы и улучшить общую стабильность системы. Вот основные метрики, на которые
стоит обратить внимание:

1. **Использование кучи (Heap Usage)**: Показывает, сколько памяти в куче используется вашим приложением. Увеличение
   использования кучи может быть признаком утечек памяти, особенно если оно не уменьшается после сборок мусора.

2. **Сборки мусора (Garbage Collection Metrics)**: Включает в себя информацию о количестве и продолжительности сборок
   мусора. Частые и длительные сборки мусора могут указывать на проблемы с производительностью и потенциальные утечки
   памяти.

    - **Счетчик сборок мусора (GC Count)**: Количество произведенных сборок мусора.
    - **Время сборки мусора (GC Time)**: Общее время, затраченное на сборку мусора.

3. **Поколения кучи (Heap Generations Sizes)**: Включает размеры различных поколений в куче (молодое поколение, старое
   поколение и поколение постоянных объектов в зависимости от версии Java). Увеличение размера старого поколения может
   быть индикатором утечки памяти.

4. **Размер метаспейса (Metaspace Size)**: В Java 8 и более поздних версиях вместо постоянного поколения (PermGen)
   используется метаспейс. Отслеживание его размера помогает обнаружить утечки классов или чрезмерное количество
   классов.

5. **Количество загруженных и выгруженных классов (Class Loading and Unloading)**: Утечки памяти могут быть связаны с
   загрузкой классов. Важно отслеживать количество загруженных классов и убедиться, что ненужные классы корректно
   выгружаются.

6. **Использование непереходящей памяти (Non-Heap Memory Usage)**: Включает в себя использование памяти за пределами
   кучи, такой как метаспейс и код кэша. Утечки в этих областях также могут влиять на производительность приложения.

7. **Потоки (Thread Metrics)**: Включает в себя количество активных и зомби-потоков. Незавершенные потоки могут
   удерживать объекты в памяти, что приведет к утечкам.

8. **Процент использования CPU и памяти операционной системы**: Хотя это не специфично для Java, высокое потребление CPU
   или памяти может указывать на неэффективное использование ресурсов вашим приложением.

### Как избежать утечек памяти?

Избежать утечек памяти в Java и других языках программирования можно, следуя лучшим практикам проектирования и
разработки. Вот несколько рекомендаций, которые помогут предотвратить утечки памяти:

#### 1. Освобождайте ресурсы

- **Закрывайте ресурсы**: Всегда закрывайте ресурсы (файлы, сетевые соединения, соединения с базой данных и т.д.) как
  можно скорее после использования. Используйте блоки `try-with-resources` для автоматического закрытия ресурсов.

#### 2. Управление коллекциями

- **Очищайте коллекции**: Удаляйте объекты из коллекций, когда они больше не нужны. Особенно внимательно относитесь к
  использованию статических коллекций, так как они остаются в памяти в течение всего срока службы приложения.

#### 3. Избегайте статических ссылок

- **Осторожно используйте статические переменные**: Статические переменные остаются в памяти в течение всего времени
  работы приложения. Если они содержат ссылки на большие объекты или коллекции, это может привести к утечкам памяти.

#### 4. Проектирование с учетом утечек памяти

- **Используйте слабые ссылки**: Рассмотрите возможность использования слабых ссылок (`WeakReference`), когда храните
  ссылки на большие объекты, которые могут быть освобождены сборщиком мусора, если это возможно.
- **Паттерны проектирования**: Будьте осторожны с паттернами проектирования, которые могут способствовать утечкам,
  такими как Singleton или Observer, и рассмотрите возможность использования слабых ссылок для обработчиков событий.

#### 5. Профилирование и мониторинг

- **Регулярно профилируйте приложение**: Используйте инструменты профилирования, такие как VisualVM, JProfiler или
  YourKit, чтобы регулярно проверять приложение на наличие утечек памяти.
- **Мониторинг**: Настройте мониторинг ключевых метрик производительности, чтобы получать предупреждения о потенциальных
  проблемах с памятью.

#### 6. Обучение и осведомленность

- **Повышайте осведомленность**: Разработчики должны быть осведомлены о том, как работают сборщик мусора и управление
  памятью в Java, а также о том, какие шаблоны использования кода могут привести к утечкам памяти.

#### 7. Тестирование

- **Юнит-тестирование и интеграционное тестирование**: Пишите тесты для проверки того, что объекты должным образом
  удаляются после использования. Используйте библиотеки, такие как JUnit, для автоматизации тестирования.
- **Нагрузочное тестирование**: Регулярно проводите нагрузочное тестирование, чтобы обнаруживать утечки памяти, которые
  могут проявляться только при определенных условиях.

### Расскажите, что такое DI?

### Что значит “управляем спрингом”?

### Что такое Bean

В контексте Spring Framework, термин "бин" (bean) относится к объекту, который управляется контейнером Spring IoC (
Inversion of Control). Бины являются основными строительными блоками любого приложения на Spring, представляя собой
компоненты приложения, которыми управляет Spring.

### Жизненный цикл бина

Жизненный цикл бина в Spring Framework описывает различные этапы, через которые проходит бин от момента его создания до
уничтожения. Понимание этих этапов важно для корректного использования ресурсов и управления состоянием приложения. Вот
ключевые этапы жизненного цикла бина в Spring:

#### 1. Инстанцирование

- **Описание**: Spring создает экземпляр бина, используя его конструктор. Этот процесс включает в себя выделение памяти
  для бина и вызов конструктора класса.

#### 2. Заполнение свойств

- **Описание**: Spring инъектирует значения в свойства бина, определенные в конфигурации. Это может быть выполнено через
  XML-конфигурацию, аннотации или Java-конфигурацию.

#### 3. Вызов методов жизненного цикла

- Если бин реализует интерфейсы `InitializingBean` или `DisposableBean`, Spring вызывает методы `afterPropertiesSet`
  и `destroy` соответственно. Эти методы предоставляют бину возможность выполнить инициализацию после установки всех
  необходимых свойств и очистку перед уничтожением.
- Для бинов, конфигурированных через XML или аннотации, можно указать методы инициализации и уничтожения, используя
  атрибуты `init-method` и `destroy-method` или аннотации `@PostConstruct` и `@PreDestroy`.

#### 4. Post-Processing

- **Описание**: После инициализации бина, но перед его использованием, Spring предоставляет возможность выполнения
  дополнительной конфигурации или логики через BeanPostProcessors. `BeanPostProcessor` может модифицировать бин или
  вернуть новый прокси-бин для использования.

#### 5. Готовность к использованию

- **Описание**: После всех этапов инициализации бин готов к использованию в приложении.

#### 6. Уничтожение

- **Описание**: Когда контейнер Spring закрывается, он уничтожает синглтонные бины (не прототипы, поскольку Spring не
  управляет полным жизненным циклом прототипов после создания). Это включает в себя вызов конфигурируемых методов
  уничтожения бина. В это время бин может освободить ресурсы, которые он занял во время своей работы.

Понимание жизненного цикла бина в Spring позволяет разработчикам лучше управлять ресурсами, корректно использовать бины
и их зависимости, а также интегрировать собственные процессы инициализации и уничтожения.

### Способы заинжектить бин

В Spring Framework существует несколько способов внедрения (инъекции) зависимостей в бины. Это основной механизм для
управления бинами и их зависимостями в контексте приложения. Вот основные способы внедрения зависимостей в бины:

#### 1. Внедрение через конструктор (Constructor Injection)

- **Описание**: Зависимости внедряются через конструктор класса при создании объекта. Этот способ обеспечивает
  неизменяемость созданного бина и гарантирует, что все зависимости бина инициализированы до его использования.
- **Пример**:
  ```java
  @Component
  public class MyService {
      private final MyDependency myDependency;

      @Autowired
      public MyService(MyDependency myDependency) {
          this.myDependency = myDependency;
      }
  }
  ```

#### 2. Внедрение через сеттер (Setter Injection)

- **Описание**: Зависимости внедряются через сеттеры или другие методы после создания объекта. Этот способ позволяет
  бину оставаться изменяемым и удобен, когда внедрение через конструктор невозможно или неудобно из-за большого
  количества зависимостей.
- **Пример**:
  ```java
  @Component
  public class MyService {
      private MyDependency myDependency;

      @Autowired
      public void setMyDependency(MyDependency myDependency) {
          this.myDependency = myDependency;
      }
  }
  ```

#### 3. Внедрение через поля (Field Injection)

- **Описание**: Зависимости внедряются непосредственно в поля класса без использования сеттеров или конструктора. Хотя
  этот способ наиболее прост и удобен, он считается менее предпочтительным по сравнению с внедрением через конструктор
  из-за потенциальных трудностей с тестированием и нарушением инкапсуляции.
- **Пример**:
  ```java
  @Component
  public class MyService {
      @Autowired
      private MyDependency myDependency;
  }
  ```

#### 4. Внедрение через методы (Method Injection)

- **Описание**: Этот способ похож на внедрение через сеттер, но используется для внедрения зависимостей через
  произвольные методы, не являющиеся сеттерами. Spring вызовет эти методы с нужными зависимостями после создания бина.
- **Пример**:
  ```java
  @Component
  public class MyService {
      private MyDependency myDependency;

      @Autowired
      public void anyMethodName(MyDependency myDependency) {
          this.myDependency = myDependency;
      }
  }
  ```

#### 5. Внедрение через аннотации `@Resource` и `@Inject`

- **Описание**: Альтернативные способы внедрения, `@Resource` и `@Inject`, предоставляют функциональность,
  аналогичную `@Autowired`, но с некоторыми различиями в поведении и настройках.
- **Пример с @Resource**:
  ```java
  @Component
  public class MyService {
      @Resource
      private MyDependency myDependency;
  }
  ```
- **Пример с @Inject**:
  ```java
  @Component
  public class MyService {
      @Inject
      private MyDependency myDependency;
  }
  ```

Каждый из этих способов имеет свои преимущества и недостатки, и выбор определенного метода зависит от конкретных
требований приложения и предпочтений разработчика.

### Какие есть скоупы?

В Spring Framework существуют различные области видимости (scopes) для бинов, которые определяют их жизненный цикл и
область видимости в контексте приложения. Вот основные скоупы, доступные в Spring:

#### 1. Singleton

- **Описание**: По умолчанию используется область видимости Singleton. Это означает, что в пределах одного Spring IoC
  контейнера создается единственный экземпляр бина. Все последующие запросы к этому бину будут возвращать тот же самый
  экземпляр.
- **Применение**: Подходит для безсостоянийных сервисов, где необходим единственный экземпляр для всего приложения.

#### 2. Prototype

- **Описание**: Область видимости Prototype означает, что каждый раз при запросе бина создается новый экземпляр.
- **Применение**: Используется, когда нужны различные экземпляры бина для разных задач или когда бин хранит состояние,
  специфичное для каждого использования.

#### 3. Request

- **Описание**: Бин в области видимости Request создается и существует в рамках одного HTTP запроса. Каждый новый HTTP
  запрос будет иметь свой экземпляр бина.
- **Применение**: Применяется в веб-приложениях для хранения информации, специфичной для одного запроса.

#### 4. Session

- **Описание**: Бины в области видимости Session создаются на уровне HTTP сессии. Для каждой новой сессии будет создан
  свой экземпляр бина.
- **Применение**: Используется для хранения информации, специфичной для сессии пользователя в веб-приложении.

#### 5. Application

- **Описание**: Область видимости Application аналогична Singleton, но в отличие от него, бин существует на уровне всего
  веб-приложения (ServletContext), а не одного Spring IoC контейнера.
- **Применение**: Подходит для хранения глобальных данных приложения, доступных всем его частям.

#### 6. WebSocket

- **Описание**: Этот скоуп предназначен для использования в приложениях с WebSocket. Бин в этой области видимости
  существует на протяжении одной WebSocket сессии.
- **Применение**: Используется для работы с данными, специфичными для WebSocket сессии.

Выбор подходящего скоупа зависит от требований к управлению жизненным циклом бина и его видимости в приложении.
Основываясь на этих требованиях, разработчики могут определить, какой скоуп наиболее подходит для каждого конкретного
случая.

### Что такое Spring

### Что такое Spring framework?

### В чем отличие Spring Boot от Spring?

### Зачем нужен Spring Boot

### Что использовал из SpringData

### Что использовал из SpringSecurity

### Максимально глубоко рассказать про устройство SpringCore

Spring Core — это ключевая часть фреймворка Spring, представляющая собой контейнер зависимостей (Dependency Injection,
DI). Он обеспечивает основу для конфигурации и управления Java объектами через механизм инверсии управления (Inversion
of Control, IoC). Эта основа позволяет разработчикам создавать гибкие, расширяемые и легко тестируемые приложения.
Давайте подробно рассмотрим ключевые компоненты и принципы работы Spring Core.

#### 1. Инверсия управления (IoC) и контейнер IoC

Инверсия управления — это принцип, при котором создание экземпляров объектов и управление их жизненным циклом
перекладывается с программиста на фреймворк. В контексте Spring это означает, что контейнер Spring IoC создает и
управляет вашими бинами (компонентами приложения), связывая их вместе во время выполнения.

#### 2. Бины

Бины — это объекты, которые управляются контейнером Spring. Они создаются, управляются и конфигурируются через контейнер
IoC. Определения бинов могут быть объявлены в XML-файлах, аннотациями в коде или через Java-конфигурацию.

#### 3. Зависимости

Зависимости — это объекты, необходимые другим объектам для выполнения их функций. Spring автоматически управляет
зависимостями между бинами, внедряя их через конструкторы, сеттеры или поля напрямую.

#### 4. Автосвязывание

Автосвязывание позволяет Spring автоматически связывать бины по типу, имени или конструкторам. Это снижает необходимость
в явном определении связей между компонентами, делая конфигурацию более простой и читаемой.

#### 5. Области видимости бинов

Spring поддерживает несколько областей видимости для бинов, включая синглтон (один экземпляр на контейнер), прототип (
новый экземпляр каждый раз при запросе), и области видимости запроса и сессии для веб-приложений.

#### 6. Жизненный цикл бина

Жизненный цикл бина в Spring включает этапы создания, настройки свойств и зависимостей, инициализации, использования и
уничтожения. Spring предоставляет различные способы для вмешательства в эти этапы, например, через аннотации
@PostConstruct и @PreDestroy.

#### 7. Конфигурация

Spring позволяет конфигурировать приложения через XML, аннотации и Java-конфигурацию. Это дает разработчикам гибкость в
выборе подходящего способа настройки приложения в зависимости от их предпочтений и требований проекта.

#### 8. Расширяемость

Spring Core разработан с учетом расширяемости, позволяя разработчикам добавлять свои собственные компоненты, аспекты,
обработчики и бины для решения специфических задач.

#### 9. Интеграция с другими фреймворками

Spring Core хорошо интегрируется с другими фреймворками и библиотеками, такими как Hibernate, JPA, Spring MVC и многими
другими, что позволяет
разработчикам использовать лучшие практики и решения из разных областей.

Важность Spring Core в экосистеме Spring трудно переоценить, поскольку он лежит в основе всех других проектов Spring,
предоставляя мощные средства для создания эффективных и гибких приложений.

### Опыт работы с межсервисными протоколами (REST, SOAP, WS, PROTOBUFF, gRPC, graphQL)

### Опыт работы с модулями спринга

### Опыт работы с AOP

### Что такое Application Context

### Что находится в пакете starter и зачем он нужен

### Что такое автоконфигурация

### Способы конфигурации спринга

### Что такое Синглтон?

### чем отличается Синглтон от Прототипа

### SOLID

### Наиболее чаще всего используемые паттерны проектирования

### Где в docker приложении храниться состояния

### Как собрать Spring приложение в Docker контейнер

### Как можно вытащить логи из Docker контейнера

### Что произойдет с Kubenetes клайстером если одна нода упадет

### Реактивное программирование

### Что такое checkstyle

### Что такое SonarQube

### Что такое Mongo

### Работали с ElasticSearchили и кибана. Что это

### Реактивное программирование

### HealthCheck\HealthBeat

### В чем суть уязвимости Log4Shell

### MSA

### Service Mash

## Git

## DataBase

## Многопоточность