[< Назад](..%2F..%2FREADME.md)

<!-- TOC -->

* [Java](#java)
    * [Перечислите методы класса Object](#перечислите-методы-класса-object)
    * [Что появилось в Java 11](#что-появилось-в-java-11)
    * [Чем отличается Set от List](#чем-отличается-set-от-list)
    * [Что использовали для тестов](#что-использовали-для-тестов)
    * [Что использовали для оптимизации кода](#что-использовали-для-оптимизации-кода)
    * [Что такое мутабельность и иммутабельность](#что-такое-мутабельность-и-иммутабельность)
    * [У нас есть класс “джава ланг стринг”. Как он устроен?](#у-нас-есть-класс-джава-ланг-стринг-как-он-устроен)
    * [Что такое “внутренние библиотеки”?](#что-такое-внутренние-библиотеки)
    * [Помимо индексов сталкивались с балансированием деревьев?](#помимо-индексов-сталкивались-с-балансированием-деревьев)
    * [В узлах деревьев должны быть имутабельные объекты, что это такое?](#в-узлах-деревьев-должны-быть-имутабельные-объекты-что-это-такое)
    * [У вас возникла задача разработать неизменяемый объект, который вы будете применять в деревьях. Как вы будете его разрабатывать?](#у-вас-возникла-задача-разработать-неизменяемый-объект-который-вы-будете-применять-в-деревьях-как-вы-будете-его-разрабатывать)
    * [Как вы оцениваете трудоемкость реализации на бекэнде?](#как-вы-оцениваете-трудоемкость-реализации-на-бекэнде)
    * [Что такое Lambda?](#что-такое-lambda)
    * [Что такое функциональный интерфейс?](#что-такое-функциональный-интерфейс)
    * [Сигнатуры функций?](#сигнатуры-функций)
    * [Максимально глубоко рассказать про HashMap](#максимально-глубоко-рассказать-про-hashmap)
    * [Можно ли в HashMap использовать null в качестве ключа](#можно-ли-в-hashmap-использовать-null-в-качестве-ключа)
    * [Можно ли в ConcurrentMap использовать null в качестве ключа](#можно-ли-в-concurrentmap-использовать-null-в-качестве-ключа)
    * [В каком тайме упадет IllegalStateException (Compile или Runtime)](#в-каком-тайме-упадет-illegalstateexception-compile-или-runtime)
    * [Что будет в результате Stream.of(“1”,”2”,”3”,”4”).filter(v ->v.equals(“1”))](#что-будет-в-результате-streamof1234filterv--vequals1)
    * [Что такое Stream API?](#что-такое-stream-api)
    * [Что такое функции высшего порядка?](#что-такое-функции-высшего-порядка)
    * [Что такое InputStream и OutputStream и как они связаны со Stream API?](#что-такое-inputstream-и-outputstream-и-как-они-связаны-со-stream-api)
    * [Что вы вкладываете в слово поток?](#что-вы-вкладываете-в-слово-поток)
    * [Что такое потоковый режим?](#что-такое-потоковый-режим)
    * [В каких операциях нужно два элемента?](#в-каких-операциях-нужно-два-элемента)
    * [Операции в Stream API, они как-то отличаются друг от друга? Разновидности?](#операции-в-stream-api-они-как-то-отличаются-друг-от-друга-разновидности)
    * [Как работают стримы под капотом](#как-работают-стримы-под-капотом)
    * [Можно ли вызвать дважды у одного стрима терминирующий метод](#можно-ли-вызвать-дважды-у-одного-стрима-терминирующий-метод)
    * [Как посмотреть все ветки в git](#как-посмотреть-все-ветки-в-git)
    * [Как посмотреть все удаленные репы в git](#как-посмотреть-все-удаленные-репы-в-git)
    * [Что такое git flow](#что-такое-git-flow)
    * [Работали ли вы с базами данных?](#работали-ли-вы-с-базами-данных)
    * [С какими базами работали](#с-какими-базами-работали)
    * [Какие не реляционные СУБД использовал (IN-Memory в т.ч.)](#какие-не-реляционные-субд-использовал-in-memory-в-тч)
    * [Отличия реляционных и нереляционных](#отличия-реляционных-и-нереляционных)
    * [Как работать с реляционными базами данных?](#как-работать-с-реляционными-базами-данных)
    * [Что такое транзакции в базах данных?](#что-такое-транзакции-в-базах-данных)
    * [Что значит “данные остаются консистентными и согласованными”?](#что-значит-данные-остаются-консистентными-и-согласованными)
    * [Как сделать так, чтобы к окончанию транзакции мы точно знали, что всё посчитается корректно, посчитаются даже параллельные транзакции?](#как-сделать-так-чтобы-к-окончанию-транзакции-мы-точно-знали-что-всё-посчитается-корректно-посчитаются-даже-параллельные-транзакции)
    * [Что такое “оптимистичная блокировка”?](#что-такое-оптимистичная-блокировка)
    * [Что такое “пессимистичная блокировка”? Как это реализуетя в коде?](#что-такое-пессимистичная-блокировка-как-это-реализуетя-в-коде)
    * [Как происходила доставка схемы до базы данных?](#как-происходила-доставка-схемы-до-базы-данных)
    * [Что такое ОРМ?](#что-такое-орм)
    * [Что такое JDBC](#что-такое-jdbc)
    * [Что такое JPA](#что-такое-jpa)
    * [Что такое реляция?](#что-такое-реляция)
    * [Criteria API](#criteria-api)
    * [Что делает Explain](#что-делает-explain)
    * [Что такое репликация и шардирование](#что-такое-репликация-и-шардирование)
    * [Работы с транзакциями в Hibernate](#работы-с-транзакциями-в-hibernate)
    * [Кеширование в Hibernate](#кеширование-в-hibernate)
    * [Управление схемами данных](#управление-схемами-данных)
    * [Отличие Inner Join от Left Join](#отличие-inner-join-от-left-join)
    * [Отличие Join от Union](#отличие-join-от-union)
    * [Как работает индексация](#как-работает-индексация)
    * [В чем отличия EAGER от LAZY запросов](#в-чем-отличия-eager-от-lazy-запросов)
    * [Отличие Inner Join от Left Join](#отличие-inner-join-от-left-join-1)
    * [Отличие Join от Union](#отличие-join-от-union-1)
    * [Что такое индексы? Максимально подробно рассказать про Индексы](#что-такое-индексы-максимально-подробно-рассказать-про-индексы)
    * [Многопоточность](#многопоточность)
    * [Что такое ForkJoinPool](#что-такое-forkjoinpool)
    * [После тестирования обнаружили, что есть утечки памяти. Как вы будете выяснять, утечка ли это? Что с этим делать?](#после-тестирования-обнаружили-что-есть-утечки-памяти-как-вы-будете-выяснять-утечка-ли-это-что-с-этим-делать)
    * [Почему могут быть утечки?](#почему-могут-быть-утечки)
    * [Какие метрики вы будете отслеживать? Как они называются?](#какие-метрики-вы-будете-отслеживать-как-они-называются)
    * [Как избежать утечек памяти?](#как-избежать-утечек-памяти)
    * [Расскажите, что такое DI?](#расскажите-что-такое-di)
    * [Что значит “управляем спрингом”?](#что-значит-управляем-спрингом)
    * [Что такое Bean](#что-такое-bean)
    * [Жизненный цикл бина](#жизненный-цикл-бина)
    * [Способы заинжектить бан](#способы-заинжектить-бан)
    * [Какие есть скоупы?](#какие-есть-скоупы)
    * [Что такое Spring](#что-такое-spring)
    * [Что такое Spring framework?](#что-такое-spring-framework)
    * [В чем отличие Spring Boot от Spring?](#в-чем-отличие-spring-boot-от-spring)
    * [Зачем нужен Spring Boot](#зачем-нужен-spring-boot)
    * [Что использовал из SpringData](#что-использовал-из-springdata)
    * [Что использовал из SpringSecurity](#что-использовал-из-springsecurity)
    * [Максимально глубоко рассказать про устройство SpringCore](#максимально-глубоко-рассказать-про-устройство-springcore)
    * [Опыт работы с межсервисными протоколами (REST, SOAP, WS, PROTOBUFF, gRPC, graphQL)](#опыт-работы-с-межсервисными-протоколами-rest-soap-ws-protobuff-grpc-graphql)
    * [Опыт работы с модулями спринга](#опыт-работы-с-модулями-спринга)
    * [Опыт работы с AOP](#опыт-работы-с-aop)
    * [Что такое Application Context](#что-такое-application-context)
    * [Что находится в пакете starter и зачем он нужен](#что-находится-в-пакете-starter-и-зачем-он-нужен)
    * [Что такое автоконфигурация](#что-такое-автоконфигурация)
    * [Способы конфигурации спринга](#способы-конфигурации-спринга)
    * [Что такое Синглтон?](#что-такое-синглтон)
    * [чем отличается Синглтон от Прототипа](#чем-отличается-синглтон-от-прототипа)
    * [SOLID](#solid)
    * [Наиболее чаще всего используемые паттерны проектирования](#наиболее-чаще-всего-используемые-паттерны-проектирования)
    * [Где в docker приложении храниться состояния](#где-в-docker-приложении-храниться-состояния)
    * [Как собрать Spring приложение в Docker контейнер](#как-собрать-spring-приложение-в-docker-контейнер)
    * [Как можно вытащить логи из Docker контейнера](#как-можно-вытащить-логи-из-docker-контейнера)
    * [Что произойдет с Kubenetes клайстером если одна нода упадет](#что-произойдет-с-kubenetes-клайстером-если-одна-нода-упадет)
    * [Реактивное программирование](#реактивное-программирование)
    * [Что такое checkstyle](#что-такое-checkstyle)
    * [Что такое SonarQube](#что-такое-sonarqube)
    * [Что такое Mongo](#что-такое-mongo)
    * [Работали с ElasticSearchили и кибана. Что это](#работали-с-elasticsearchили-и-кибана-что-это)
    * [Реактивное программирование](#реактивное-программирование-1)
    * [HealthCheck\HealthBeat](#healthcheckhealthbeat)
    * [В чем суть уязвимости Log4Shell](#в-чем-суть-уязвимости-log4shell)
    * [MSA](#msa)
    * [Service Mash](#service-mash)
* [Git](#git)
* [DataBase](#database)
* [Многопоточность](#многопоточность-1)

<!-- TOC -->

## Java

### Перечислите методы класса Object

* clone
* equals
* finalize (Deprecated)
* getClass
* hashCode
* toString
* notify
* notifyAll
* wait

### Что появилось в Java 11

Удаление JavaFX, Java EE и CORBA. Новый HTTP-клиент: Введен новый HTTP-клиент (java.net.http), который заменяет
устаревший HttpURLConnection. Можно напрямую запускать файлы .java, не компилируя их в .class. Улучшенная интеграция с
Docker

### Чем отличается Set от List

В Java, `Set` и `List` являются интерфейсами, которые наследуются от коллекции `Collection` и представляют собой два
различных способа хранения элементов. Вот основные различия между `Set` и `List`:

1. **Уникальность элементов**:

- `Set` хранит только уникальные элементы. То есть, в коллекции типа `Set` не может быть двух объектов, которые
  считаются равными с точки зрения метода `equals()`.
- `List` может содержать дублирующие элементы. То есть, один и тот же объект может присутствовать в `List` множество
  раз.

2. **Порядок хранения**:

- `List` гарантирует, что элементы будут храниться в порядке их добавления. Это означает, что есть возможность получить
  элемент по его индексу.
- В `Set` порядок хранения элементов не гарантирован. Некоторые реализации `Set`, например `LinkedHashSet`, сохраняют
  порядок добавления элементов, в то время как другие, как `HashSet`, не обеспечивают никакого порядка.

3. **Получение доступа к элементам**:

- В `List` можно легко получить доступ к элементу по его индексу благодаря методу `get(index)`.
- В `Set` нет прямого способа получить доступ к элементу по индексу, так как элементы не индексированы. Доступ к
  элементам обычно осуществляется через итератор.

4. **Производительность**:

- В зависимости от реализации, `Set` может обеспечивать более быстрое выполнение операций добавления, удаления и
  проверки наличия элемента, поскольку многие реализации `Set` используют хэш-таблицы. Например, `HashSet`.
- Для `List` производительность этих операций может быть ниже, особенно когда речь идет о больших объемах данных, так
  как поиск элемента требует перебора списка.

5. **Выбор реализации**:

- Для `Set` есть несколько реализаций, включая `HashSet`, `LinkedHashSet`, и `TreeSet`, каждая из которых имеет свои
  особенности по части порядка элементов и производительности.
- `List` имеет две основные реализации: `ArrayList` и `LinkedList`. `ArrayList` предоставляет быстрый доступ к элементам
  по индексу, в то время как `LinkedList` оптимизирован для операций добавления и удаления.

Как `Set`, так и `List` являются важными инструментами в языке программирования Java, и выбор между ними зависит от
конкретных требований к коллекции в вашем приложении.

### Что использовали для тестов

Для тестирования в Java, особенно в приложениях, разработанных с использованием Spring Framework, используются различные
инструменты и библиотеки. Вот некоторые из них:

1. **JUnit**: Самая популярная библиотека для модульного тестирования в Java. JUnit предоставляет аннотации и классы для
   написания тестов и включает возможности для организации тестовых случаев и генерации отчетов о тестировании. Spring
   поддерживает интеграцию с JUnit для удобства тестирования компонентов Spring.

2. **Mockito**: Фреймворк для создания и использования мок-объектов (объектов-заглушек) в Java. Mockito позволяет
   имитировать поведение классов или интерфейсов для изолированного тестирования компонентов. Это особенно полезно при
   тестировании взаимодействия между компонентами без необходимости создавать сложные зависимости.

3. **Spring Test**: Библиотека, предоставляемая Spring Framework, предлагает обширные возможности для тестирования
   компонентов Spring, включая интеграционные и модульные тесты. Она обеспечивает поддержку загрузки контекста Spring и
   кэширования между тестами, что ускоряет выполнение тестов.

4. **Spring Boot Test**: Часть Spring Boot, предоставляющая удобные аннотации и авто-конфигурацию для тестирования
   приложений Spring Boot. Она включает поддержку тестирования REST-контроллеров, JSON-содержимого, HTML-страниц и
   многое другое.

5. **Hamcrest**: Библиотека для улучшения читаемости кода тестов за счет использования "matcher" выражений. Hamcrest
   позволяет писать более выразительные утверждения в тестах.

Эти инструменты и библиотеки предоставляют мощный набор возможностей для разработки тестов на всех уровнях: от
модульного тестирования до интеграционных и функциональных тестов.

### Что использовали для оптимизации кода

Оптимизация кода в Java и в рамках использования Spring Framework может включать в себя различные подходы и инструменты.
Вот некоторые из наиболее распространенных методов и инструментов для оптимизации:

1. **Профайлинг кода**: Использование профайлеров, например JProfiler, для идентификации узких мест в
   производительности, избыточного использования памяти или утечек памяти.

2. **JMH (Java Microbenchmark Harness)**: Официальный инструмент для создания, запуска и анализа микробенчмарков,
   разработанный группой разработки JDK. Это особенно полезно для точной оценки производительности отдельных блоков
   кода.

4. **Checkstyle, PMD, SonarQube**: Инструменты для статического анализа кода, которые помогают обнаружить проблемы с
   качеством кода, потенциальные узкие места, неэффективные конструкции и нарушения стилевых гайдлайнов.

5. **Spring Boot Actuator**: Для приложений на Spring Boot, Actuator предоставляет встроенные конечные точки для
   мониторинга и управления приложением, включая метрики производительности, состояние бина, здоровье приложения и
   другие.

6. **Кэширование**: Использование Spring Cache или других библиотек кэширования, таких как EhCache или Hazelcast, для
   сокращения времени отклика приложения путем хранения результатов дорогостоящих операций.

7. **Оптимизация запросов к базе данных**: Использование JPA/Hibernate профилировщиков или логирования SQL для
   оптимизации запросов к базе данных, устранения N+1 проблемы запросов и улучшения производительности операций с базой
   данных.

### Что такое мутабельность и иммутабельность

### У нас есть класс “джава ланг стринг”. Как он устроен?

[Как устроен String](string_pool_in_java.md)

### Что такое “внутренние библиотеки”?

В Java "внутренние библиотеки" относятся к стандартной библиотеке Java (Java Standard Library), которая также известна
как Java API (Application Programming Interface). Эти библиотеки предоставляют разработчикам набор предопределенных
классов и интерфейсов для выполнения различных задач, таких как ввод-вывод данных, управление сетевыми соединениями,
разработка графического пользовательского интерфейса, обработка дат и времени, и многое другое.

Стандартная библиотека Java является частью Java Development Kit (JDK) и автоматически доступна при разработке
приложений на Java. Она организована в пакеты, каждый из которых предназначен для определенной области задач. Например:

- `java.lang`: содержит классы, которые являются фундаментальными для языка программирования Java, такие
  как `String`, `Math`, `System`, и классы оболочки для примитивных типов данных.
- `java.util`: предлагает классы и интерфейсы для работы с коллекциями данных (например, списками, множествами,
  картами), а также для выполнения различных вспомогательных функций, таких как генерация случайных чисел, дата и время.
- `java.io`: предоставляет классы для чтения и записи данных (ввода-вывода), включая работу с файлами.
- `java.net`: содержит классы для работы с сетью, включая выполнение HTTP запросов и работы с URL.

Эти и другие пакеты в стандартной библиотеке Java позволяют разработчикам быстро создавать мощные и эффективные
приложения, не заботясь о низкоуровневой реализации многих стандартных функций.

### Помимо индексов сталкивались с балансированием деревьев?

### В узлах деревьев должны быть имутабельные объекты, что это такое?

### У вас возникла задача разработать неизменяемый объект, который вы будете применять в деревьях. Как вы будете его разрабатывать?

### Как вы оцениваете трудоемкость реализации на бекэнде?

Оценка трудоемкости реализации на бекэнде зависит от многих факторов, таких как сложность проекта, требования к
производительности и безопасности, использование технологий и инструментов, а также опыт и навыки команды разработчиков.
Вот несколько ключевых аспектов, которые стоит учитывать при оценке трудоемкости:

#### 1. Требования к проекту

- **Сложность функционала**: Более сложные задачи требуют больше времени и ресурсов.
- **Интеграция с внешними системами**: Интеграция с API, сторонними сервисами или сложными базами данных может увеличить
  трудоемкость.
- **Требования к безопасности**: Реализация мер безопасности, таких как шифрование данных, аутентификация и авторизация
  пользователей, требует дополнительных ресурсов.
- **Масштабируемость**: Проектирование системы с учетом будущего роста и нагрузки может потребовать дополнительных
  усилий.

#### 2. Технологический стек

- **Выбор языка программирования и фреймворков**: Некоторые языки и фреймворки могут ускорить разработку за счет готовых
  решений и библиотек.
- **Использование готовых решений и библиотек**: Использование готовых компонентов может существенно сократить время
  разработки.

#### 3. Команда

- **Опыт и навыки команды**: Опытные разработчики могут быстрее справиться с задачами и находить более эффективные
  решения.
- **Размер команды**: Большая команда может выполнять задачи быстрее, но также требуется время на координацию и
  коммуникацию.

#### 4. Процесс разработки

- **Методология разработки**: Гибкие методологии, такие как Agile, могут ускорить разработку за счет итеративного
  подхода и постоянной обратной связи.
- **Тестирование**: Включение автоматизированных тестов и непрерывной интеграции может увеличить начальную трудоемкость,
  но сократить время на поиск и исправление ошибок в долгосрочной перспективе.

#### 5. Управление проектом

- **Планирование и отслеживание**: Тщательное планирование и регулярное отслеживание прогресса помогает избежать
  задержек и перерасхода ресурсов.

Оценка трудоемкости — это сложный процесс, требующий учета множества переменных. Часто используются методы экспертных
оценок, такие как Planning Poker, или формализованные подходы, например, Function Point Analysis, чтобы сделать оценку
более объективной и точной.

### Что такое Lambda?

Lambda (или лямбда-выражение) в Java — это способ предоставления реализации интерфейса с одним абстрактным методом (
также известного как функциональный интерфейс) в компактной форме. Лямбда-выражения были добавлены в Java 8 и
представляют собой одну из ключевых особенностей, позволяющих писать более краткий и читаемый код, особенно когда речь
идет о работе с коллекциями или потоками данных.

### Что такое функциональный интерфейс?

Функциональный интерфейс в Java — это интерфейс, который содержит только один абстрактный метод.

### Сигнатуры функций?

Сигнатура функции (или метода) в программировании — это определение, которое включает имя функции, количество и типы
параметров и тип возвращаемого значения. Сигнатура функции не включает тело функции (то есть конкретные инструкции
функции) и часто используется для определения интерфейса, которому должны соответствовать различные реализации функции.

### Максимально глубоко рассказать про HashMap

### Можно ли в HashMap использовать null в качестве ключа

### Можно ли в ConcurrentMap использовать null в качестве ключа

Нет, в `ConcurrentMap` в Java нельзя использовать `null` ни в качестве ключа, ни в качестве значения. Попытка
вставить `null` в `ConcurrentMap` (как `ConcurrentHashMap`, так и любые другие реализации этого интерфейса) приведет к
выбросу исключения `NullPointerException`. Это ограничение обусловлено потребностью в обеспечении атомарности операций и
предотвращении проблем синхронизации, так как `null` значения могут вызвать двусмысленность в логике синхронизации и
состоянии коллекции.

### В каком тайме упадет IllegalStateException (Compile или Runtime)

`IllegalStateException` является исключением времени выполнения (runtime exception) в Java. Это непроверяемое
исключение, которое может быть выброшено, чтобы указать на то, что метод был вызван в неподходящее время, или же
состояние объекта не позволяет выполнить запрашиваемую операцию. Поскольку это исключение происходит во время выполнения
программы, оно не требует обработки с помощью блоков `try-catch` или указания в сигнатуре метода с помощью `throws`,
хотя это и может быть сделано для улучшения качества кода.

### Что будет в результате Stream.of(“1”,”2”,”3”,”4”).filter(v ->v.equals(“1”))

### Что такое Stream API?

Stream API в Java — это набор классов и интерфейсов в пакете `java.util.stream`, который представляет собой
высокоуровневую абстракцию для обработки последовательностей элементов. Этот API был введён в Java 8 и позволяет
описывать сложные операции над данными в виде высокоуровневых конструкций, используя концепции функционального
программирования.

Stream API предоставляет два вида операций:

1. **Промежуточные операции (Intermediate operations)** — такие операции возвращают новый поток, и поэтому они могут
   быть соединены в цепочки (они «ленивые» и не выполняются до тех пор, пока не будет вызвана терминальная операция).
   Примеры включают `filter`, `map`, `sorted`.

2. **Терминальные операции (Terminal operations)** — такие операции завершают поток и выдают результат. Такие операции,
   как `forEach`, `collect`, `reduce`, `findFirst`.

Stream API имеет несколько преимуществ:

- **Выразительность**: Часто можно описать сложную обработку данных в несколько строк кода.
- **Легко читаемый код**: Операции Stream часто являются более читаемыми и компактными, чем традиционные конструкции,
  такие как циклы.
- **Поддержка функционального стиля программирования**: Stream API делает простым использование функций высшего порядка
  для операций над данными.
- **Ленивые вычисления**: Промежуточные операции не выполняют никаких вычислений, пока не будет вызвана терминальная
  операция.
- **Параллелизм**: Стримы могут быть легко выполнены параллельно для улучшения производительности без необходимости
  изменения кода, если данные не имеют состояния и операции являются независимыми.

### Что такое функции высшего порядка?

Функции высшего порядка — это функции, которые могут принимать другие функции в качестве параметров или возвращать
функции как результат своей работы. Это позволяет программистам создавать более абстрактные уровни операций, где функции
используются как значения. Это ключевой аспект функционального программирования.

### Что такое InputStream и OutputStream и как они связаны со Stream API?

`InputStream` и `OutputStream` в Java — это абстрактные классы, представляющие потоки ввода и вывода данных
соответственно. Они являются частью пакета `java.io` и используются для чтения и записи байтов (для `InputStream`) или
для записи байтов (для `OutputStream`), и это может быть файл, сетевое соединение, память и т.д.

- **InputStream** предоставляет общий интерфейс для чтения байтовых данных. Например, метод `read()` читает следующий
  байт данных из потока.
- **OutputStream** предоставляет общий интерфейс для записи байтовых данных. Например, метод `write(int b)` записывает
  указанный байт в поток.

Эти потоки являются блокирующими и ориентированы на работу с байтами, что отличается от работы с потоками
в `java.util.stream`, которые представляют потоки объектов и используются для работы с последовательностями данных,
поддерживая функциональные операции.

Stream API в Java, представленный в Java 8, это совершенно другая концепция и относится к потокам
объектов (`java.util.stream`), а не байтов. Stream API предоставляет механизмы для обработки коллекций объектов с
использованием функциональных операций, таких как `map`, `filter`, `reduce`. Потоки Stream API поддерживают как
последовательные, так и параллельные операции и являются основой для функционального стиля программирования в Java.

Хотя `InputStream`/`OutputStream` и Stream API оба используют термин «stream», они предназначены для разных целей и
работают с разными типами данных. `InputStream`/`OutputStream` — для байтов и бинарных данных, а Stream API — для
объектов и операций над ними на высоком уровне абстракции.

### Что вы вкладываете в слово поток?

Слово "поток" в контексте программирования чаще всего относится к последовательности элементов, обрабатываемых в
определенной последовательности.

### Что такое потоковый режим?

Потоковый режим или потоковая передача данных — это способ обработки или передачи данных, при котором они передаются и
обрабатываются последовательно, часто без знания общего объема данных. Это противоположность пакетной обработке, где
обработка начинается только после получения всех доступных данных.

### В каких операциях нужно два элемента?

В программировании существует несколько операций, для которых требуются два элемента. Вот несколько примеров:

1. **Арифметические операции**: Сложение (+), вычитание (-), умножение (*), деление (/), остаток от деления (%). Каждая
   из этих операций принимает два операнда. Например, `a + b` или `x / y`.

2. **Логические операции**: Логическое И (&&), логическое ИЛИ (||). Эти операции используются для соединения двух
   булевых выражений. Например, `expression1 && expression2`.

3. **Битовые операции**: Битовое И (&), битовое ИЛИ (|), исключающее ИЛИ (^), сдвиг влево (<<), сдвиг вправо (>>). Эти
   операции выполняются над двумя числовыми значениями. Например, `number1 & number2`.

4. **Сравнения**: Равенство (==), неравенство (!=), меньше (<), больше (>), меньше или равно (<=), больше или
   равно (>=). Эти операторы сравнивают два значения. Например, `a < b`.

5. **Операции с коллекциями**: Например, `Map.put(key, value)` требует ключ и значение для сохранения в карте.

6. **Функциональные интерфейсы**: Некоторые функциональные интерфейсы в Java, такие как `BiFunction<T, U, R>`
   или `BiPredicate<T, U>`, определены для принятия двух аргументов.

7. **Методы с двумя параметрами**: Методы, требующие двух параметров для выполнения. Например, `Math.max(a, b)` для
   нахождения максимального из двух значений.

8. **Конструкторы**: Некоторые конструкторы объектов требуют двух параметров для инициализации объекта.
   Например, `Point(x, y)` может требовать координаты x и y.

9. **Терминальные операции в Stream API**: Операция `reduce` принимает два параметра — начальное значение и функцию,
   которая будет применяться к элементам потока.

10. **Лямбда выражения и методы**: В лямбда выражениях или методах могут быть использованы два параметра.
    Например, `(x, y) -> x + y` или `void compare(String a, String b)`.

### Операции в Stream API, они как-то отличаются друг от друга? Разновидности?

Stream API предоставляет два вида операций:

1. **Промежуточные операции (Intermediate operations)** — такие операции возвращают новый поток, и поэтому они могут
   быть соединены в цепочки (они «ленивые» и не выполняются до тех пор, пока не будет вызвана терминальная операция).
   Примеры включают `filter`, `map`, `sorted`.

2. **Терминальные операции (Terminal operations)** — такие операции завершают поток и выдают результат. Такие операции,
   как `forEach`, `collect`, `reduce`, `findFirst`.

### Как работают стримы под капотом

Под капотом стримы в Java работают на основе нескольких ключевых принципов и компонентов:

1. **Пайплайнинг (Pipelining)**: Операции со стримами формируют "пайплайн" — цепочку операций, которая применяется
   последовательно. Промежуточные операции обрабатывают данные и передают их дальше по цепочке, не производя обработку
   всех данных сразу.

2. **Ленивость (Laziness)**: Промежуточные операции являются ленивыми, то есть они не выполняются до тех пор, пока не
   будет вызвана терминальная операция. Это позволяет избежать лишней работы, например, при использовании
   операций `limit` или `findFirst`.

3. **Внутренние итерации (Internal Iterations)**: В отличие от внешних итераций с помощью циклов, стримы используют
   внутренние итерации, скрывая детали обхода элементов, что упрощает многопоточное выполнение.

4. **Неизменяемость (Immutability)**: Стримы не изменяют исходные данные. Вместо этого они, как правило, возвращают
   новые стримы с результатами промежуточных операций.

5. **Параллелизм (Parallelism)**: Стримы могут быть выполнены параллельно с помощью метода `parallel`, который разбивает
   данные на части, обрабатывает их в разных потоках и затем собирает результаты.

6. **Функциональные интерфейсы (Functional Interfaces)**: Стримы тесно связаны с функциональными
   интерфейсами (`Predicate`, `Function`, `Consumer` и т. д.), которые предоставляют методы для выполнения операций над
   элементами.

7. **Сплитераторы (Spliterators)**: Для работы с параллельными стримами используются сплитераторы, которые разделяют
   данные на части для параллельной обработки. Сплитераторы определяют, как данные будут разделены и в какой
   последовательности будут обрабатываться элементы.

8. **Коллекторы (Collectors)**: Для сбора данных из стримов в коллекции или другие структуры данных используются
   коллекторы, предоставляемые классом `Collectors`.

9. **Оптимизация**: Некоторые операции стримов могут быть оптимизированы под капотом. Например, `map` и `filter` могут
   быть объединены в одну операцию, чтобы минимизировать проходы по данным.

10. **Состояние**: Некоторые промежуточные операции, такие как `distinct` и `sorted`, требуют сохранения состояния (
    запоминания элементов, которые уже были обработаны).

Сама модель стримов — это больше о паттерне проектирования, который позволяет разработчикам использовать функциональные
стили программирования в Java, абстрагируя многие сложные аспекты обработки данных, такие как параллелизм и оптимизация
итераций.

### Можно ли вызвать дважды у одного стрима терминирующий метод

Нет, терминирующий метод у одного и того же стрима вызвать дважды нельзя. После вызова терминальной операции поток
считается «исчерпанным» или «закрытым», и любая попытка использовать его снова приведет к `IllegalStateException`. Если
вам нужно выполнить несколько терминальных операций с одинаковыми данными, вам следует создать новый поток для каждой
операции.

### Как посмотреть все ветки в git

git branch -a

### Как посмотреть все удаленные репы в git

Чтобы посмотреть все удалённые репозитории, к которым ваш локальный Git репозиторий имеет доступ, можно использовать
команду `git remote -v`. Эта команда выведет список всех удалённых подключений, включая URL для операций fetch и push
для каждого удалённого репозитория.

Если вам нужно увидеть удалённые ветки, сначала выполните `git fetch --prune`. Опция `--prune` удалит ссылки на
удалённое отслеживание, которые больше не существуют в удалённом репозитории. Затем командой `git branch -r` вы можете
просмотреть все удалённые ветки; удалённые ветки в списке уже не будут отображаться.

### Что такое git flow

Git Flow — это модель ветвления для Git, предложенная Винсентом Дриессеном в 2010 году. Она определяет
стандартизированный набор веток и правил их использования, что облегчает управление версиями и разработку в командах. В
Git Flow выделяют следующие типы веток:

1. **Основные ветки:**
    - `master`: стабильная ветка, содержащая код, готовый к релизу в продакшен.
    - `develop`: основная ветка для разработки, все новые фичи сначала попадают сюда.

2. **Вспомогательные ветки:**
    - `feature`: ветки для разработки новых функций, создаются от `develop` и вливаются обратно в `develop`.
    - `release`: ветки для подготовки релизов, они позволяют финализировать релиз и устранять ошибки перед тем, как код
      попадёт в `master`.
    - `hotfix`: ветки для срочного исправления ошибок в коде, который уже находится в продакшене. Создаются от `master`
      и вливаются в `master` и `develop`.

Помимо структуры веток, Git Flow предполагает конкретный рабочий процесс:

- Новые фичи разрабатываются в соответствующих ветках `feature/`, которые потом сливаются с `develop`.
- Когда разработка фичей для следующего релиза завершена, создаётся ветка `release/`, где происходит финальная
  подготовка к выпуску версии.
- После проверки и готовности, ветка `release` сливается в `master` и помечается тегом с номером версии.
- Если в продакшене обнаруживается баг, создаётся `hotfix/`, который после исправления вливается обратно в `master`
  и `develop`.

Git Flow хорошо подходит для проектов, где чётко определены стадии разработки и выпуска версий, а также важен строгий
контроль за стабильностью продакшен-версии.

### Работали ли вы с базами данных?

### С какими базами работали

### Какие не реляционные СУБД использовал (IN-Memory в т.ч.)

Вот некоторые из них:

1. **Документо-ориентированные базы данных**:
    - **MongoDB**: хранит данные в формате BSON, похожем на JSON.

2. **Ключ-значение хранилища**:
    - **Redis**: in-memory хранилище, часто используется как кэш или для хранения сессий.

5. **Поисковые системы**:
    - **Elasticsearch**: не только база данных, но и поисковая система и аналитическая платформа.

6. **Базы данных для мобильных приложений**:
    - **Firebase Realtime Database**: база данных в реальном времени от Google.
    - **Realm**: легковесная и быстрая база данных, оптимизированная для мобильных устройств.

Каждая из этих систем предлагает свои особенности и преимущества, в зависимости от требований к производительности,
удобству масштабирования, типа хранимых данных и сложности запросов. In-memory базы данных, такие как Redis, обычно
используются для задач, требующих высокой скорости доступа к данным.

### Отличия реляционных и нереляционных

Реляционные (SQL) и нереляционные (NoSQL) системы управления базами данных (СУБД) имеют ряд ключевых отличий:

**1. Схема данных:**

- **Реляционные СУБД**: Имеют строгую схему с таблицами, строки которых содержат данные, а столбцы — атрибуты. Все
  данные должны соответствовать схеме, что требует планирования перед вставкой данных.
- **Нереляционные СУБД**: Гибкие в отношении схемы данных. Могут хранить документо-ориентированные данные,
  ключ-значение, графы и широкостолбцовые хранилища. Не требуют заранее определенной схемы, и структура данных может
  изменяться "на лету".

**2. Запросы:**

- **Реляционные СУБД**: Используют язык SQL для создания, чтения, обновления и удаления данных (CRUD операции), который
  является мощным и стандартизированным средством запросов.
- **Нереляционные СУБД**: Используют разнообразные способы запросов, которые зависят от типа СУБД, включая RESTful API,
  специфичные для базы данных языки запросов или даже использование кода (например, JavaScript).

**3. Транзакции:**

- **Реляционные СУБД**: Обычно поддерживают многошаговые транзакции и обеспечивают свойства ACID (атомарность,
  согласованность, изолированность, долговечность), что критично для приложений, где необходима строгая консистентность
  данных.
- **Нереляционные СУБД**: Некоторые поддерживают транзакции, но они могут быть ограничены или работать по-другому. В
  целом, NoSQL СУБД склонны к обеспечению свойств BASE (базовая доступность, мягкая состояние, конечная
  согласованность), что подразумевает более легкую консистентность для обеспечения лучшей доступности и разделения.

**4. Масштабируемость:**

- **Реляционные СУБД**: Традиционно оптимизированы для вертикального масштабирования, что означает улучшение аппаратных
  характеристик сервера.
- **Нереляционные СУБД**: Часто разработаны с учетом горизонтального масштабирования, распределения данных по множеству
  серверов, что делает их более гибкими в управлении большими объемами данных.

**5. Работа с данными:**

- **Реляционные СУБД**: Идеально подходят для сложных запросов и операций, требующих точной связи между таблицами
  данных.
- **Нереляционные СУБД**: Лучше подходят для сценариев, где необходима быстрая запись/чтение операций и где связи между
  данными менее структурированы или не так важны.

Выбор между реляционной и нереляционной СУБД зависит от требований конкретного приложения, требуемой производительности,
гибкости, масштабируемости и

### Как работать с реляционными базами данных?

### Что такое транзакции в базах данных?

### Что значит “данные остаются консистентными и согласованными”?

Когда говорят, что "данные остаются консистентными и согласованными", это означает, что они сохраняют целостность и
точность в течение всего времени их жизни в базе данных или системе. В контексте управления данными, консистентность и
согласованность относятся к нескольким важным аспектам:

1. **Консистентность**: Данные считаются консистентными, если они соответствуют определённым правилам и ограничениям.
   Например, в реляционной базе данных, консистентность данных может быть обеспечена с помощью ограничений целостности,
   таких как внешние ключи, правила проверки (check constraints) и триггеры. Консистентность обеспечивает, что любые
   операции с данными (вставка, обновление, удаление) не нарушат эти ограничения.

2. **Согласованность**: Согласованность данных означает, что данные в разных частях системы не противоречат друг другу и
   обновляются синхронно. Например, если одна часть системы обновляет данные, другие части должны отражать это
   обновление и не содержать старых или устаревших значений.

В контексте транзакций и баз данных, эти понятия часть свойств ACID:

- **Atomicity (Атомарность)**: транзакция выполняется полностью или не выполняется вообще.
- **Consistency (Консистентность)**: транзакция не нарушит никаких правил или ограничений базы данных и после её
  выполнения база данных будет в консистентном состоянии.
- **Isolation (Изоляция)**: транзакции выполняются независимо друг от друга.
- **Durability (Долговечность)**: после завершения транзакции, её результаты сохраняются и не могут быть потеряны.

Таким образом, обеспечение консистентности и согласованности в данных — критический аспект управления данными, который
помогает поддерживать порядок, предотвращать ошибки и упрощать анализ и отчётность.

### Как сделать так, чтобы к окончанию транзакции мы точно знали, что всё посчитается корректно, посчитаются даже параллельные транзакции?

Для гарантии корректности вычислений в конце транзакции, а также учета параллельно выполняемых транзакций, СУБД
используют механизмы, обеспечивающие ACID свойства. Вот как это обычно достигается:

1. **Атомарность (Atomicity)**: СУБД гарантируют, что каждая транзакция либо выполняется полностью, либо не выполняется
   вовсе. Это достигается через механизмы, такие как журналирование транзакций, которые позволяют восстановить
   предыдущее состояние в случае ошибки.

2. **Консистентность (Consistency)**: Ограничения целостности данных (например, внешние ключи, ограничения уникальности)
   помогают обеспечить, что данные останутся консистентными после каждой транзакции. СУБД не допустят завершения
   транзакции, если она нарушает эти ограничения.

3. **Изоляция (Isolation)**: Уровни изоляции транзакций контролируют, как и когда результаты выполнения одной транзакции
   становятся видимыми для других транзакций. Строгая изоляция может защитить от проблем, таких как "грязное чтение" (
   dirty reads), "неповторяющееся чтение" (non-repeatable reads) и "фантомное чтение" (phantom reads). В системах, где
   требуется высокая производительность и допустимо некоторое ослабление строгости, могут использоваться более слабые
   уровни изоляции.

4. **Долговечность (Durability)**: После подтверждения транзакции, СУБД гарантируют, что её результаты сохранятся, даже
   в случае сбоя системы. Это достигается через механизмы вроде записи в журнал транзакций и точек сохранения (
   checkpoints).

Для обработки параллельных транзакций и обеспечения консистентности, СУБД могут использовать различные стратегии, такие
как:

- **Блокировки (Locking)**: СУБД могут применять блокировки к ресурсам (строкам, страницам, таблицам), чтобы
  контролировать доступ и предотвратить конфликты между транзакциями.
- **Оптимистичное управление параллелизмом**: Подразумевает проверку на конфликты в конце транзакции и откат, если
  таковые обнаружены.
- **Многоверсионное управление параллелизмом (MVCC)**: Каждая транзакция работает с "снимком" данных, что позволяет
  избежать блокировок при чтении и улучшить параллелизм.

Выбор стратегии и настройка уровней изоляции транзакций зависят от конкретных требований приложения к производительности
и консистентности данных. В идеале, разработчики и администраторы баз данных должны стремиться к балансу между строгой
изоляцией транзакций для точности и гибкостью для эффективной параллельной работы.

### Что такое “оптимистичная блокировка”?

Оптимистичная блокировка — это стратегия управления параллелизмом в системах управления базами данных, которая
предполагает, что конфликты при доступе к данным возникают редко, и что лучше позволить транзакциям выполняться без
блокировок, предполагая минимальный риск конфликта. Вместо того чтобы удерживать блокировки на данные в течение всей
транзакции, система с оптимистичной блокировкой отслеживает изменения и, при попытке подтвердить транзакцию, проверяет
наличие конфликтов. Если конфликтов нет, транзакция завершается успешно. Если же конфликты обнаружены, транзакция
откатывается.

Пример работы оптимистичной блокировки:

1. **Начало транзакции**: Вы начинаете транзакцию и читаете некоторые данные.

2. **Выполнение работы**: Вы выполняете работу в приложении, возможно, изменяя данные, но не устанавливаете блокировку
   на них в базе данных.

3. **Подтверждение транзакции**: При попытке подтвердить транзакцию система проверит, не были ли изменены данные с
   момента их первого чтения. Это обычно делается путем проверки маркеров версий (версионирование данных) или хешей.

4. **Обработка конфликтов**: Если данные не изменились, транзакция подтверждается. Если данные изменились другой
   транзакцией, текущая транзакция откатывается, и, возможно, повторяется попытка.

Оптимистичная блокировка подходит для сред, где блокировка или транзакции на длительное время могут негативно сказаться
на производительности системы из-за низкой вероятности конфликтов. Напротив, пессимистичная блокировка (где блокировки
удерживаются на протяжении всей транзакции) больше подходит для систем, где конфликты более вероятны.

### Что такое “пессимистичная блокировка”? Как это реализуетя в коде?

### Как происходила доставка схемы до базы данных?

### Что такое ОРМ?

### Что такое JDBC

### Что такое JPA

### Что такое реляция?

### Criteria API

### Что делает Explain

### Что такое репликация и шардирование

### Работы с транзакциями в Hibernate

### Кеширование в Hibernate

### Управление схемами данных

### Отличие Inner Join от Left Join

### Отличие Join от Union

### Как работает индексация

### В чем отличия EAGER от LAZY запросов

### Отличие Inner Join от Left Join

### Отличие Join от Union

### Что такое индексы? Максимально подробно рассказать про Индексы

### Многопоточность

### Что такое ForkJoinPool

### После тестирования обнаружили, что есть утечки памяти. Как вы будете выяснять, утечка ли это? Что с этим делать?

Утечка памяти в Java может быть довольно сложной для выявления и устранения, потому что сборщик мусора автоматически
управляет памятью. Однако даже в такой среде утечки могут происходить, особенно если объекты, которые больше не нужны,
по-прежнему доступны через ссылки из доступных областей памяти.

#### Выявление утечек памяти

1. **Используйте профилировщики памяти**: Инструменты, такие как VisualVM, JProfiler, или YourKit, позволяют наблюдать
   за потреблением памяти вашего приложения в реальном времени, выявлять объекты, которые занимают больше всего памяти,
   и определять, какие из них не освобождаются.

2. **Анализ дампов памяти**: При подозрении на утечку вы можете создать дамп памяти (heap dump) с помощью инструментов,
   таких как `jmap`, или автоматически при возникновении `OutOfMemoryError`, если установлен соответствующий флаг
   JVM (`-XX:+HeapDumpOnOutOfMemoryError`). Затем анализируйте дамп с помощью Eclipse Memory Analyzer (MAT) или других
   аналогичных инструментов, чтобы найти объекты, которые занимают большую часть памяти и пути их достижения, что
   поможет определить причину утечки.

3. **Проверьте статические поля**: Объекты, на которые ссылаются статические поля, остаются в памяти на протяжении всего
   времени работы приложения. Если такие объекты динамически накапливают ссылки на другие объекты, это может привести к
   утечкам.

4. **Внимательно отнеситесь к коллекциям**: Неправильное использование коллекций (например, HashMap, ArrayList) может
   привести к утечкам памяти, если из коллекций не удаляются объекты.

5. **Проверьте использование внешних ресурсов**: Утечки также могут происходить из-за неправильного управления
   ресурсами, такими как соединения с базой данных, файловые дескрипторы или потоки.

#### Устранение утечек памяти

- **Исправление кода**: Как только вы идентифицируете проблемные области с помощью профилировщиков или анализа дампов
  памяти, вам нужно изменить код таким образом, чтобы устранить утечки. Это может включать в себя удаление лишних ссылок
  на объекты, правильное закрытие ресурсов в блоках `finally` или использование конструкций `try-with-resources`.

- **Оптимизация использования коллекций**: Убедитесь, что объекты удаляются из коллекций, когда они больше не нужны.

- **Использование слабых ссылок**: В некоторых случаях использование слабых ссылок (`WeakReference`) может помочь.
  Объекты, на которые ссылаются только слабые ссылки, могут быть собраны сборщиком мусора, даже если ссылки еще
  существуют.

- **Проведение регрессионного тестирования**: После внесения изменений в код, проведите регрессионное тестирование,
  чтобы убедить

### Почему могут быть утечки?

Утечки памяти в Java и других языках программирования могут возникать по множеству причин. В контексте управляемой
среды, такой как Java, где сборщик мусора автоматически управляет выделением и освобождением памяти, утечки памяти
обычно происходят, когда объекты, которые больше не нужны приложению, по-прежнему удерживаются в памяти из-за
существующих ссылок на них. Вот некоторые конкретные причины, по которым могут возникать утечки памяти:

1. **Неправильное управление коллекциями**: Объекты могут быть добавлены в коллекцию и никогда не удаляться, даже когда
   они больше не используются. Это особенно верно для статических коллекций, которые остаются в памяти в течение всего
   срока службы приложения.

2. **Статические поля**: Если статическое поле ссылается на объект, эта ссылка остается активной в течение всего времени
   работы приложения, что может привести к утечке памяти, если объект больше не нужен, но все еще доступен через
   статическую ссылку.

3. **Наблюдатели и обратные вызовы**: Подписка на события или регистрация обратных вызовов без соответствующей отписки
   может привести к утечкам памяти, поскольку объекты обработчиков событий могут быть удерживаемы дольше, чем
   необходимо.

4. **Закрытие ресурсов**: Неудачное или отсутствующее закрытие ресурсов, таких как потоки ввода-вывода, соединения с
   базой данных или файловые дескрипторы, может привести к утечке ресурсов, что иногда называют "утечкой ресурсов", хотя
   это и отличается от утечек памяти.

5. **Кэширование без стратегии истечения срока действия**: Кэширование объектов без политики очистки или истечения срока
   действия может привести к накоплению неиспользуемых объектов в памяти.

6. **Неправильное использование сторонних библиотек**: Иногда утечки памяти могут быть вызваны ошибками или недостатками
   в сторонних библиотеках, которые использует ваше приложение.

7. **Потоки**: Незавершенные или "зомби" потоки, которые продолжают выполняться после того, как они должны были быть
   завершены, могут удерживать объекты в памяти, предотвращая их сбор.

8. **Паттерны проектирования**: Некоторые паттерны проектирования, если они используются неправильно, могут
   способствовать утечкам памяти. Например, Singleton или Observer могут удерживать ссылки на объекты дольше, чем
   требуется.

Решение этих проблем требует тщательного анализа и профилирования приложения, а также осознанного использования ресурсов
и ссылок в вашем коде.

### Какие метрики вы будете отслеживать? Как они называются?

При диагностике утечек памяти и мониторинге производительности Java-приложений важно отслеживать ряд ключевых метрик,
которые помогут выявить потенциальные проблемы и улучшить общую стабильность системы. Вот основные метрики, на которые
стоит обратить внимание:

1. **Использование кучи (Heap Usage)**: Показывает, сколько памяти в куче используется вашим приложением. Увеличение
   использования кучи может быть признаком утечек памяти, особенно если оно не уменьшается после сборок мусора.

2. **Сборки мусора (Garbage Collection Metrics)**: Включает в себя информацию о количестве и продолжительности сборок
   мусора. Частые и длительные сборки мусора могут указывать на проблемы с производительностью и потенциальные утечки
   памяти.

    - **Счетчик сборок мусора (GC Count)**: Количество произведенных сборок мусора.
    - **Время сборки мусора (GC Time)**: Общее время, затраченное на сборку мусора.

3. **Поколения кучи (Heap Generations Sizes)**: Включает размеры различных поколений в куче (молодое поколение, старое
   поколение и поколение постоянных объектов в зависимости от версии Java). Увеличение размера старого поколения может
   быть индикатором утечки памяти.

4. **Размер метаспейса (Metaspace Size)**: В Java 8 и более поздних версиях вместо постоянного поколения (PermGen)
   используется метаспейс. Отслеживание его размера помогает обнаружить утечки классов или чрезмерное количество
   классов.

5. **Количество загруженных и выгруженных классов (Class Loading and Unloading)**: Утечки памяти могут быть связаны с
   загрузкой классов. Важно отслеживать количество загруженных классов и убедиться, что ненужные классы корректно
   выгружаются.

6. **Использование непереходящей памяти (Non-Heap Memory Usage)**: Включает в себя использование памяти за пределами
   кучи, такой как метаспейс и код кэша. Утечки в этих областях также могут влиять на производительность приложения.

7. **Потоки (Thread Metrics)**: Включает в себя количество активных и зомби-потоков. Незавершенные потоки могут
   удерживать объекты в памяти, что приведет к утечкам.

8. **Процент использования CPU и памяти операционной системы**: Хотя это не специфично для Java, высокое потребление CPU
   или памяти может указывать на неэффективное использование ресурсов вашим приложением.

### Как избежать утечек памяти?

### Расскажите, что такое DI?

### Что значит “управляем спрингом”?

### Что такое Bean

### Жизненный цикл бина

### Способы заинжектить бан

### Какие есть скоупы?

### Что такое Spring

### Что такое Spring framework?

### В чем отличие Spring Boot от Spring?

### Зачем нужен Spring Boot

### Что использовал из SpringData

### Что использовал из SpringSecurity

### Максимально глубоко рассказать про устройство SpringCore

### Опыт работы с межсервисными протоколами (REST, SOAP, WS, PROTOBUFF, gRPC, graphQL)

### Опыт работы с модулями спринга

### Опыт работы с AOP

### Что такое Application Context

### Что находится в пакете starter и зачем он нужен

### Что такое автоконфигурация

### Способы конфигурации спринга

### Что такое Синглтон?

### чем отличается Синглтон от Прототипа

### SOLID

### Наиболее чаще всего используемые паттерны проектирования

### Где в docker приложении храниться состояния

### Как собрать Spring приложение в Docker контейнер

### Как можно вытащить логи из Docker контейнера

### Что произойдет с Kubenetes клайстером если одна нода упадет

### Реактивное программирование

### Что такое checkstyle

### Что такое SonarQube

### Что такое Mongo

### Работали с ElasticSearchили и кибана. Что это

### Реактивное программирование

### HealthCheck\HealthBeat

### В чем суть уязвимости Log4Shell

### MSA

### Service Mash

## Git

## DataBase

## Многопоточность