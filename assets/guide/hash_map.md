[< Назад](..%2F..%2FREADME.md)

# HashMap под микроскопом

<!-- TOC -->
* [HashMap под микроскопом](#hashmap-под-микроскопом)
  * [Подготовка к пониманию](#подготовка-к-пониманию)
    * [Хэш-таблица](#хэш-таблица)
    * [Хэш-код](#хэш-код)
    * [Как сделать хеш максимально разным](#как-сделать-хеш-максимально-разным)
  * [Определение HashMap](#определение-hashmap)
  * [Свойства HashMap:](#свойства-hashmap)
    * [Доступные для получения](#доступные-для-получения)
    * [Capacity (ёмкость)](#capacity-ёмкость)
      * [Инициализация и изменение ёмкости](#инициализация-и-изменение-ёмкости)
      * [Влияние на производительность](#влияние-на-производительность)
      * [Коэффициент загрузки](#коэффициент-загрузки)
    * [Доступные для модификации во время создания](#доступные-для-модификации-во-время-создания)
    * [Остальные свойства, которые нам неподвластны](#остальные-свойства-которые-нам-неподвластны)
    * [Важные константы](#важные-константы)
  * [Создание объекта](#создание-объекта)
    * [По умолчанию](#по-умолчанию)
    * [С указанием стартовой ёмкости](#с-указанием-стартовой-ёмкости)
    * [С указанием стартовой ёмкости и коэффициента загрузки](#с-указанием-стартовой-ёмкости-и-коэффициента-загрузки)
  * [Структура хранения данных](#структура-хранения-данных)
    * [Node (бакет)](#node-бакет)
  * [Добавление элементов](#добавление-элементов)
<!-- TOC -->

## Подготовка к пониманию

### Хэш-таблица

**Хэш-таблица** — это структура данных, которая позволяет выполнять операции вставки, удаления и поиска элементов за
предполагаемо константное время, то есть время выполнения этих операций не зависит от количества элементов в таблице.
Это достигается за счет использования хэш-функции, которая преобразует ключ элемента в индекс массива, где и будет
храниться значение.

Принцип работы хэш-таблицы основан на следующих понятиях:

- **Хэш-функция**: Функция, которая принимает на вход ключ элемента и возвращает индекс для этого ключа в массиве.
  Идеальная хэш-функция должна равномерно распределять ключи по всему массиву, чтобы избежать коллизий.
- **Коллизия**: Ситуация, когда два разных ключа имеют один и тот же хэш-код и, следовательно, претендуют на одно и то
  же местоположение в хэш-таблице. Для решения проблемы коллизий существуют различные методы, такие как открытая
  адресация (линейное и квадратичное исследование, двойное хеширование) и метод цепочек.
- **Метод цепочек**: Один из способов разрешения коллизий, при котором в каждой ячейке массива хранится указатель на
  список (или цепочку) всех элементов, чьи ключи хэшируются в этот индекс. Если происходит коллизия, новый элемент
  просто добавляется в список.
- **Открытая адресация**: Другой способ разрешения коллизий, при котором все элементы хранятся непосредственно в
  массиве.
  Если произошла коллизия, алгоритм ищет следующий свободный индекс в таблице по определенному правилу (линейное
  исследование, квадратичное исследование, двойное хеширование). (**Для нас это не интересно**)

### Хэш-код

Хэш-код объекта в Java получается при помощи метода `hashCode()`, который определён в классе `Object` и может быть
переопределен в пользовательских классах для обеспечения уникальности хэш-кодов и повышения эффективности работы
хэш-таблиц.

Если метод `hashCode()` не переопределен в классе, тогда используется реализация этого метода из класса `Object`.
Реализация `hashCode()` в классе `Object` нативная, и она предназначена для возвращения целочисленного значения, которое
является хеш-кодом объекта. Это значение по умолчанию обычно зависит от внутреннего адреса объекта в памяти JVM (Java
Virtual Machine). Однако точное поведение может варьироваться между различными реализациями JVM и не гарантирует
возвращение уникальных идентификаторов для разных объектов.

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)
@IntrinsicCandidate
public native int hashCode();
```

### Как сделать хеш максимально разным

- **Переопределение `hashCode()`:** Для объектов, используемых в качестве ключей, важно переопределить
  метод `hashCode()`, чтобы он генерировал хеш-коды, равномерно распределенные по возможному диапазону значений.

- **Комбинирование характеристик объекта:** При переопределении `hashCode()`, рекомендуется комбинировать характеристики
  объекта (например, поля класса), используя стабильные и разнообразные операции (сложение, умножение на простые числа и
  т.д.), чтобы обеспечить уникальность и равномерное распределение хеш-кодов.

- **Избегание зависимости от порядка:** Для объектов, содержащих коллекции или массивы, при вычислении хеш-кода важно
  учитывать, что порядок элементов не должен влиять на итоговый хеш. Это помогает предотвратить коллизии для объектов,
  которые логически эквивалентны, но имеют разный порядок элементов.

Применяя эти подходы, можно значительно уменьшить количество коллизий в `HashMap` и улучшить производительность операций

> Данный пример использует комбинацию полей для генерации хеш-кода с хорошим распределением. При создании хеш-кода важно
> использовать простые числа в качестве множителей, чтобы увеличить случайность распределения и минимизировать
> количество коллизий. Этот метод основан на рекомендациях из книги "Effective Java" Джошуа Блоха.

```java
public class Person {
    private String name;
    private int age;
    private String email;

    // Конструктор
    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    // Геттеры и сеттеры
    // ...    

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name) &&
                Objects.equals(email, person.email);
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        result = 31 * result + (email != null ? email.hashCode() : 0);
        return result;
    }
}
```

> Для вычисления `hashCode()` используется 31 — простое число. Это приводит к тому, что результат хеш-функции
> максимально равномерно распределен по возможному диапазону значений `int`. Использование простого числа помогает
> избежать коллизий, потому что умножение на простое число и комбинация результатов хеш-кодов от различных полей класса
> создает большое количество уникальных хеш-кодов для разных объектов.

> Также важно переопределить метод `equals()` в соответствии с `hashCode()`, чтобы сохранить контракт между `hashCode()`
> и `equals()`, который гласит, что если два объекта равны по `equals()`, то их хеш-коды также должны быть равны.


Выбор числа 31 в качестве множителя в методе `hashCode()` в примере класса `Person` основан на нескольких важных
соображениях, описанных в книге "Effective Java" авторства Джошуа Блоха. **Почему же именно 31** является
предпочтительным
выбором для таких расчетов:

1. **31 — простое число:** Использование простого числа в качестве множителя способствует созданию более равномерного
   распределения хеш-кодов. Простые числа в выборе хеш-функций традиционно используются для уменьшения числа коллизий.
   Простые числа не имеют делителей, кроме 1 и самих себя, что делает их хорошим выбором для распределения значений.

2. **31 можно умножить сдвигом и вычитанием:** Умножение на 31 может быть заменено на сдвиг влево на 5 позиций и
   вычитание исходного числа. Это операция `(x << 5) - x`, которая выполняется быстрее, чем прямое умножение, особенно
   на старых архитектурах процессоров. Хотя современные компиляторы и процессоры оптимизируют умножение настолько
   хорошо, что разница в производительности может быть незаметна, такой подход был важен в прошлом и продолжает
   использоваться во многих реализациях хеш-функций.

3. **Маленькое, но не слишком маленькое число:** 31 достаточно большое, чтобы вносить разнообразие в расчет хеш-кода, но
   в то же время достаточно маленькое, чтобы избежать переполнения целого числа слишком быстро.

Поэтому выбор числа 31 в качестве множителя в методе `hashCode()` является своего рода конвенцией, основанной на
компромиссе между скоростью вычисления и качеством распределения хеш-кодов. Этот выбор подчеркивает, как важно
использовать в хеш-функциях числа, которые способствуют созданию уникальных и равномерно распределенных хеш-кодов для
объектов.

## Определение HashMap

HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение).
Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не дает гарантий относительно порядка
элементов с течением времени. Разрешение коллизий осуществляется с помощью метода цепочек.

## Свойства HashMap:

### Доступные для получения

- **size** — Количество элементов HashMap-а;

```
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224) 

transient int size; // Поле
map.size(); // Вызов
```

- **entrySet** — Set<Map.Entry<K, V>>, поговорим чуть позже;

``` 
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

// Поле
transient Set<Map.Entry<K, V>> entrySet;

// Геттер
public Set<Map.Entry<K, V>> entrySet() {
    Set<Map.Entry<K, V>> es;
    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
}

map.entrySet(); // Вызов
```

### Capacity (ёмкость)

`HashMap` имеет понятие `capacity` (ёмкость), которое является важным фактором, влияющим на его производительность и
эффективность использования памяти. `Capacity` представляет собой количество "бакетов" или "слотов", доступных для
хранения элементов в `HashMap`. Каждый бакет может хранить одну или несколько пар ключ-значение, образуя так называемую
цепочку в случае коллизий.

> **ВАЖНОЕ УСЛОВИЕ !!!**
>
> Значение `capacity` должно быть равное степени двойки

**ВАЖНОЕ УСЛОВИЕ** обеспечивает метод `tableSizeFor`

```java
// Java version "11.0.8" 2020-07-14 LTS SE Runtime Environment 18.9 (build 11.0.8+10-LTS)
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

/* Метод обеспечивает, чтобы емкость всегда была степенью числа 2.
 * В контексте HashSet или HashMap, tableSizeFor используется для расчета длины массива.
 */
static final int tableSizeFor(int cap) {
    /*
     * В Java >>> оператор осуществляет беззнаковый сдвиг вправо.
     * Это означает, что он сдвигает биты числа -1 вправо.
     * -1 в бинарной форме представляет собой всё ведущие единицы.
     * При операции сдвига вправо, ведущие (левые) биты заполняются нулями.
     *
     * Integer.numberOfLeadingZeros(cap - 1): Этот метод в Java используется для определения количества нулевых битов,
     * предшествующих самому левому (или старшему) биту '1' в двоичном представлении числа cap - 1.
     * Таким образом, данная строчка кода применяет беззнаковый сдвиг вправо к числу -1, на число бит,
     * равное количеству ведущих нулей в cap - 1.
     * Это ключевой шаг, который позволяет найти ближайшую степень двойки, большую или равную cap.
     */
    int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);

    /*
     * Это составное условное выражение. Если n меньше 0, функция возвращает 1. Если n больше или равно MAXIMUM_CAPACITY (константе, определенной где-то в коде), то возвращается значение MAXIMUM_CAPACITY. В противном случае, к n прибавляется 1 и возвращается полученное число.
     */
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

```java
// Java version "11.0.8" 2020-07-14 LTS SE Runtime Environment 18.9 (build 11.0.8+10-LTS)
static final int tableSizeFor(int cap) {
    int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

```java
// Java version "1.8.0_221" SE Runtime Environment (build 1.8.0_221-b11)

static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

#### Инициализация и изменение ёмкости

- При создании `HashMap`, вы можете указать начальную ёмкость (или она будет установлена в значение по умолчанию, если
  вы этого не сделаете).
- `HashMap` автоматически увеличивает свою ёмкость (т.е. количество бакетов), когда количество элементов в ней достигает
  определённого порогового значения. Этот процесс называется "рехешированием".

#### Влияние на производительность

- **Производительность доступа**: В идеальных условиях (когда отсутствуют коллизии) время доступа к элементу (`get`
  и `put` операции) в `HashMap` может быть близко к O(1), т.е. константное время. Однако, при наличии коллизий, это
  время может увеличиваться, так как элементы в одном бакете хранятся в виде списка (или дерева, в зависимости от
  количества элементов в бакете) и для доступа к элементу необходимо пройтись по этому списку.
- **Память**: Увеличение ёмкости приводит к увеличению потребления памяти, поскольку создаётся больше бакетов для
  хранения элементов. Это важно учитывать при работе с очень большими наборами данных.

#### Коэффициент загрузки

- Вместе с понятием ёмкости тесно связан коэффициент загрузки (`loadFactor`), который представляет собой меру того,
  насколько плотно `HashMap` заполнена перед тем, как её ёмкость будет увеличена. Это значение, вещественное число
  меньшее 1, по умолчанию равное 0.75 в Java, что означает, что рехеширование произойдёт, когда `HashMap` будет
  заполнена на 75%.
- Коэффициент загрузки представляет собой компромисс между временем доступа и потреблением памяти, где более высокий
  коэффициент загрузки уменьшает потребление памяти за счёт некоторого увеличения времени доступа и наоборот.

### Доступные для модификации во время создания

- **loadFactor** — Коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа
  и объемом хранимых данных;

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

/**
 * Коэффициент загрузки, используемый, если он не указан в конструкторе.
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

Задается через конструктор:

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

HashMap<String, String> map = new HashMap<>(64, 0.75F); // 64 - capacity,  0.75F - loadFactor
```

- **threshold** — Предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое (На
  следующую степень двойки).
  Рассчитывается по формуле (**capacity** * **loadFactor**);

### Остальные свойства, которые нам неподвластны

- **table** — Массив Node<K, V>[], который является хранилищем ссылок на списки (цепочки) значений;

- **modCount** — Количество структурных изменений в коллекции. Структурные изменения – это любые изменения, которые
  модифицируют структуру самого HashMap, такие как добавление, удаление элементов, очистка (**clear()**) или
  слияние (**merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)**). Это поле
  используется для реализации fail-fast поведения итераторов.

### Важные константы

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

/**
 * Начальная емкость - ДОЛЖНО быть степенью двойки.
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16 (2 в степени 4 или сдвиг в лево на 4)
//00000000 00000000 00000000 00000001 << 4 = 00000000 00000000 00000000 00010000
/**
 * Максимальная емкость, используется, если неявно указано более высокое значение
 * любым из конструкторов с аргументами.
 * ДОЛЖНО быть степенью двойки
 */
static final int MAXIMUM_CAPACITY = 1 << 30; // 1_073_741_824 - (2 в степени 30 или сдвиг в лево на 30)
//00000000 00000000 00000000 00000001 << 30 = 01000000 00000000 00000000 00000000


/**
 * Определяет пороговое значение для преобразования связного списка в
 * красно-черное дерево в конкретном бакете хеш-таблицы.
 */
static final int TREEIFY_THRESHOLD = 8;

/**
 * Определяет, когда сбалансированное дерево (красно-черное) должно быть преобразовано обратно в
 * связный список в определённом бакете хеш-таблицы.
 */
static final int UNTREEIFY_THRESHOLD = 6;

/**
 * Определяет минимальный размер массива хеш-таблицы, необходимый для преобразования связных списков в деревья.
 * Этот параметр используется для предотвращения преобразования связных списков в деревья, 
 * если общая емкость хеш-таблицы слишком мала. Преобразование связных списков в деревья 
 * при малом размере хеш-таблицы может быть неэффективным и привести к избыточным накладным расходам,
 * особенно когда хеш-таблица могла бы просто быть расширена для улучшения распределения элементов.
 */
static final int MIN_TREEIFY_CAPACITY = 64;
```

## Создание объекта

### По умолчанию

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

HashMap<String, String> map = new HashMap<>();
```

Конструктор по умолчанию:

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
}
```

Инициализируется только `loadFactor`. Все остальные поля не проинициализированы (как пишут многие)

Новоявленный объект выглядит следующим образом:

| OFF | SZ | TYPE DESCRIPTION                        | VALUE                                     |
|-----|----|-----------------------------------------|-------------------------------------------|
| 0   | 8  | (object header: mark)                   | 0x0000000000000001 (non-biasable; age: 0) |
| 8   | 4  | (object header: class)                  | 0x000bb0d8                                |
| 12  | 4  | java.util.Set AbstractMap.keySet        | null                                      |
| 16  | 4  | java.util.Collection AbstractMap.values | null                                      |
| 20  | 4  | int HashMap.size                        | 0                                         |
| 24  | 4  | int HashMap.modCount                    | 0                                         |
| 28  | 4  | int HashMap.threshold                   | 0                                         |
| 32  | 4  | **float HashMap.loadFactor**            | **0.75**                                  |
| 36  | 4  | java.util.HashMap.Node[] HashMap.table  | null                                      |
| 40  | 4  | java.util.Set HashMap.entrySet          | null                                      |
| 44  | 4  | (object alignment gap)                  |                                           |

Instance size: 48 bytes

### С указанием стартовой ёмкости

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

HashMap<String, String> map = new HashMap<>(64);
```

Конструктор:

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
```

Инициализируется `loadFactor` и `threshold`. Все остальные поля не проинициализированы

Новоявленный объект выглядит следующим образом:

| OFF | SZ | TYPE DESCRIPTION                        | VALUE                                     |
|-----|----|-----------------------------------------|-------------------------------------------|
| 0   | 8  | (object header: mark)                   | 0x0000000000000001 (non-biasable; age: 0) |
| 8   | 4  | (object header: class)                  | 0x000bb0d8                                |
| 12  | 4  | java.util.Set AbstractMap.keySet        | null                                      |
| 16  | 4  | java.util.Collection AbstractMap.values | null                                      |
| 20  | 4  | int HashMap.size                        | 0                                         |
| 24  | 4  | int HashMap.modCount                    | 0                                         |
| 28  | 4  | **int HashMap.threshold**               | **64**                                    |
| 32  | 4  | **float HashMap.loadFactor**            | **0.75**                                  |
| 36  | 4  | java.util.HashMap.Node[] HashMap.table  | null                                      |
| 40  | 4  | java.util.Set HashMap.entrySet          | null                                      |
| 44  | 4  | (object alignment gap)                  |                                           |

Instance size: 48 bytes

### С указанием стартовой ёмкости и коэффициента загрузки

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

HashMap<String, String> map = new HashMap<>(64, 0.8F);
```

Конструктор:

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

public HashMap(int initialCapacity, float loadFactor) {
    if (initialCapacity < 0)
        throw new IllegalArgumentException("Illegal initial capacity: " +
                initialCapacity);
    if (initialCapacity > MAXIMUM_CAPACITY)
        initialCapacity = MAXIMUM_CAPACITY;
    if (loadFactor <= 0 || Float.isNaN(loadFactor))
        throw new IllegalArgumentException("Illegal load factor: " +
                loadFactor);
    this.loadFactor = loadFactor;
    this.threshold = tableSizeFor(initialCapacity);
}
```

Инициализируется `loadFactor` и `threshold`. Все остальные поля не проинициализированы

Новоявленный объект выглядит следующим образом:

| OFF | SZ | TYPE DESCRIPTION                        | VALUE                                     |
|-----|----|-----------------------------------------|-------------------------------------------|
| 0   | 8  | (object header: mark)                   | 0x0000000000000001 (non-biasable; age: 0) |
| 8   | 4  | (object header: class)                  | 0x000bb0d8                                |
| 12  | 4  | java.util.Set AbstractMap.keySet        | null                                      |
| 16  | 4  | java.util.Collection AbstractMap.values | null                                      |
| 20  | 4  | int HashMap.size                        | 0                                         |
| 24  | 4  | int HashMap.modCount                    | 0                                         |
| 28  | 4  | **int HashMap.threshold**               | **64**                                    |
| 32  | 4  | **float HashMap.loadFactor**            | **0.8**                                   |
| 36  | 4  | java.util.HashMap.Node[] HashMap.table  | null                                      |
| 40  | 4  | java.util.Set HashMap.entrySet          | null                                      |
| 44  | 4  | (object alignment gap)                  |                                           |

Instance size: 48 bytes

## Структура хранения данных

Как было сказано выше, данные хранятся в массиве `table`

```java
// Это схематичное представление создания хранилища бакетов
Node<K, V>[] table = (Node<K, V>[]) new Node[capacity];
```

### Node (бакет)

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

// Базовый узел хеш-бина, используемый для большинства записей.
static class Node<K, V> implements Map.Entry<K, V> {
    final int hash;     // Вычисленный хэш (получен от хэш-функции)
    final K key;        // Ключ
    V value;            // Значение
    Node<K, V> next;    // Ссылка на следующий элемент
    // ...
}
```

```java
// Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)

static final class TreeNode<K, V> extends LinkedHashMap.Entry<K, V> {
    TreeNode<K, V> parent;  // red-black tree links
    TreeNode<K, V> left;
    TreeNode<K, V> right;
    TreeNode<K, V> prev;    // needed to unlink next upon deletion
    boolean red;
    // ...    
}
```

## Добавление элементов

```
map.put("0", "zero");
```

При добавлении элемента, последовательность шагов следующая:

1. Вычисляется `hash` из `hashCode()` ключа. При этом применяет дополнительное смешивание хеш-кодов (например, (h =
   key.hashCode()) ^ (h >>> 16)), чтобы улучшить распределение, особенно когда количество корзин относительно мало. Это
   помогает использовать более широкий диапазон бит хеш-кода при выборе корзины, уменьшая вероятность коллизий.

    ```java
    // Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)
    static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
    ```

   > **Битовый сдвиг на 16 позиций**
   >
   >Когда происходит смешивание хеш-кодов в HashMap с использованием операции (h >>> 16), где h — это исходный хеш-код,
   цель состоит в том, чтобы обеспечить лучшее распределение хеш-кодов, особенно когда количество корзин (buckets) в
   HashMap относительно невелико. Вот ключевые моменты:
   >
   > **32-битный int:** В Java хеш-код представляет собой 32-битное целое число. Сдвиг на 16 битов вправо (>>>)
   эффективно
   перемещает старшие 16 битов хеш-кода в младшую половину.
   >
   > **Улучшение распределения:** Цель состоит в том, чтобы использовать не только младшие биты хеш-кода (которые чаще
   всего
   влияют на результат при малом количестве корзин), но и старшие биты. Это помогает улучшить распределение элементов по
   корзинам, так как старшие биты, которые могут не участвовать в расчете индекса корзины при небольшом их количестве, "
   смешиваются" с младшими, увеличивая разнообразие хеш-кодов и снижая вероятность коллизий.
   >
   > **Выбор числа 16:** Сдвиг на 16 позиций является компромиссом, который позволяет достаточно равномерно смешать биты
   хеш-кода
   без существенной потери информации. Это не делает хеш-код сложнее для вычисления, но в то же время значительно
   улучшает
   его распределение для HashMap.

2. Проверяется инициализация таблицы с бакетами (если она не проинициализирована, то инициализируем ее).
   ```
   // Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)
   if ((tab = table) == null || (n = tab.length) == 0)
       n = (tab = resize()).length;
   ```
   > Все самое интересное происходит в методе `resize()`.
3. Определяется позиция в массиве, куда будет помещен элемент.
   ```
   // Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)
   i = (n - 1) & hash
   ```
   > При значении хэша 51 и размере таблице 16, мы получаем индекс в массиве:
   > h & (length - 1) = 3
4. Теперь, зная индекс в массиве, мы получаем список (цепочку) элементов, привязанных к этой ячейке. Хэш и ключ нового
   элемента поочередно сравниваются с хэшами и ключами элементов из списка и, при совпадении этих параметров, значение
   элемента перезаписывается.
   ```
   // Java version "17.0.7" 2023-04-18 LTS SE Runtime Environment (build 17.0.7+8-LTS-224)
   if (p.hash == hash && ((k = p.key) == key || (key != null && key.equals(k))))
     e = p;
   ```
5. Если же предыдущий шаг не выявил совпадений, то...