[< Назад](..%2F..%2FREADME.md)

# HashMap под микроскопом

## Подготовка к пониманию

### Хэш-таблица

**Хэш-таблица** — это структура данных, которая позволяет выполнять операции вставки, удаления и поиска элементов за
предполагаемо константное время, то есть время выполнения этих операций не зависит от количества элементов в таблице.
Это достигается за счет использования хэш-функции, которая преобразует ключ элемента в индекс массива, где и будет
храниться значение.

Принцип работы хэш-таблицы основан на следующих понятиях:

- **Хэш-функция**: Функция, которая принимает на вход ключ элемента и возвращает индекс для этого ключа в массиве.
  Идеальная хэш-функция должна равномерно распределять ключи по всему массиву, чтобы избежать коллизий.
- **Коллизия**: Ситуация, когда два разных ключа имеют один и тот же хэш-код и, следовательно, претендуют на одно и то
  же местоположение в хэш-таблице. Для решения проблемы коллизий существуют различные методы, такие как открытая
  адресация (линейное и квадратичное исследование, двойное хеширование) и метод цепочек.
- **Метод цепочек**: Один из способов разрешения коллизий, при котором в каждой ячейке массива хранится указатель на
  список (или цепочку) всех элементов, чьи ключи хэшируются в этот индекс. Если происходит коллизия, новый элемент
  просто добавляется в список.
- **Открытая адресация**: Другой способ разрешения коллизий, при котором все элементы хранятся непосредственно в
  массиве.
  Если произошла коллизия, алгоритм ищет следующий свободный индекс в таблице по определенному правилу (линейное
  исследование, квадратичное исследование, двойное хеширование). (**Для нас это не интересно**)

### Хэш-код

Хэш-код объекта в Java получается при помощи метода `hashCode()`, который определён в классе `Object` и может быть
переопределен в пользовательских классах для обеспечения уникальности хэш-кодов и повышения эффективности работы
хэш-таблиц.

Если метод `hashCode()` не переопределен в классе, тогда используется реализация этого метода из класса `Object`.
Реализация `hashCode()` в классе `Object` нативная, и она предназначена для возвращения целочисленного значения, которое
является хеш-кодом объекта. Это значение по умолчанию обычно зависит от внутреннего адреса объекта в памяти JVM (Java
Virtual Machine). Однако точное поведение может варьироваться между различными реализациями JVM и не гарантирует
возвращение уникальных идентификаторов для разных объектов.

```java

@IntrinsicCandidate
public native int hashCode();
```

### Как сделать хеш максимально разным:

- **Переопределение `hashCode()`:** Для объектов, используемых в качестве ключей, важно переопределить
  метод `hashCode()`, чтобы он генерировал хеш-коды, равномерно распределенные по возможному диапазону значений.

- **Комбинирование характеристик объекта:** При переопределении `hashCode()`, рекомендуется комбинировать характеристики
  объекта (например, поля класса), используя стабильные и разнообразные операции (сложение, умножение на простые числа и
  т.д.), чтобы обеспечить уникальность и равномерное распределение хеш-кодов.

- **Избегание зависимости от порядка:** Для объектов, содержащих коллекции или массивы, при вычислении хеш-кода важно
  учитывать, что порядок элементов не должен влиять на итоговый хеш. Это помогает предотвратить коллизии для объектов,
  которые логически эквивалентны, но имеют разный порядок элементов.

Применяя эти подходы, можно значительно уменьшить количество коллизий в `HashMap` и улучшить производительность операций

> Данный пример использует комбинацию полей для генерации хеш-кода с хорошим распределением. При создании хеш-кода важно
> использовать простые числа в качестве множителей, чтобы увеличить случайность распределения и минимизировать
> количество коллизий. Этот метод основан на рекомендациях из книги "Effective Java" Джошуа Блоха.

```java
public class Person {
    private String name;
    private int age;
    private String email;

    // Конструктор
    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
    }

    // Геттеры и сеттеры
    // ...    

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Person person = (Person) o;
        return age == person.age &&
                Objects.equals(name, person.name) &&
                Objects.equals(email, person.email);
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        result = 31 * result + (email != null ? email.hashCode() : 0);
        return result;
    }
}
```

> Для вычисления `hashCode()` используется 31 — простое число. Это приводит к тому, что результат хеш-функции
> максимально равномерно распределен по возможному диапазону значений `int`. Использование простого числа помогает
> избежать коллизий, потому что умножение на простое число и комбинация результатов хеш-кодов от различных полей класса
> создает большое количество уникальных хеш-кодов для разных объектов.

> Также важно переопределить метод `equals()` в соответствии с `hashCode()`, чтобы сохранить контракт между `hashCode()`
> и `equals()`, который гласит, что если два объекта равны по `equals()`, то их хеш-коды также должны быть равны.


Выбор числа 31 в качестве множителя в методе `hashCode()` в примере класса `Person` основан на нескольких важных
соображениях, описанных в книге "Effective Java" авторства Джошуа Блоха. **Почему же именно 31** является
предпочтительным
выбором для таких расчетов:

1. **31 — простое число:** Использование простого числа в качестве множителя способствует созданию более равномерного
   распределения хеш-кодов. Простые числа в выборе хеш-функций традиционно используются для уменьшения числа коллизий.
   Простые числа не имеют делителей, кроме 1 и самих себя, что делает их хорошим выбором для распределения значений.

2. **31 можно умножить сдвигом и вычитанием:** Умножение на 31 может быть заменено на сдвиг влево на 5 позиций и
   вычитание исходного числа. Это операция `(x << 5) - x`, которая выполняется быстрее, чем прямое умножение, особенно
   на старых архитектурах процессоров. Хотя современные компиляторы и процессоры оптимизируют умножение настолько
   хорошо, что разница в производительности может быть незаметна, такой подход был важен в прошлом и продолжает
   использоваться во многих реализациях хеш-функций.

3. **Маленькое, но не слишком маленькое число:** 31 достаточно большое, чтобы вносить разнообразие в расчет хеш-кода, но
   в то же время достаточно маленькое, чтобы избежать переполнения целого числа слишком быстро.

Поэтому выбор числа 31 в качестве множителя в методе `hashCode()` является своего рода конвенцией, основанной на
компромиссе между скоростью вычисления и качеством распределения хеш-кодов. Этот выбор подчеркивает, как важно
использовать в хеш-функциях числа, которые способствуют созданию уникальных и равномерно распределенных хеш-кодов для
объектов.

## Определение HashMap

HashMap — основан на хэш-таблицах, реализует интерфейс Map (что подразумевает хранение данных в виде пар ключ/значение).
Ключи и значения могут быть любых типов, в том числе и null. Данная реализация не дает гарантий относительно порядка
элементов с течением времени. Разрешение коллизий осуществляется с помощью метода цепочек.

## Свойства HashMap:

### Доступные для получения

- **size** — Количество элементов HashMap-а;

```java 
transient int size; // Поле
```

```java
map.size(); // Вызов
```

- **entrySet** — Set<Map.Entry<K, V>>, поговорим чуть позже;

```java 
// Поле
transient Set<Map.Entry<K, V>> entrySet;

// Геттер
public Set<Map.Entry<K, V>> entrySet() {
    Set<Map.Entry<K, V>> es;
    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;
}
```

```java
map.entrySet(); // Вызов
```

### Capacity (ёмкость)

`HashMap` имеет понятие `capacity` (ёмкость), которое является важным фактором, влияющим на его производительность и
эффективность использования памяти. `Capacity` представляет собой количество "бакетов" или "слотов", доступных для
хранения элементов в `HashMap`. Каждый бакет может хранить одну или несколько пар ключ-значение, образуя так называемую
цепочку в случае коллизий.

> ВАЖНО!!!
>
> Значение `capacity` должно быть равное степени двойки

#### Инициализация и изменение ёмкости

- При создании `HashMap`, вы можете указать начальную ёмкость (или она будет установлена в значение по умолчанию, если
  вы этого не сделаете).
- `HashMap` автоматически увеличивает свою ёмкость (т.е. количество бакетов), когда количество элементов в ней достигает
  определённого порогового значения. Этот процесс называется "рехешированием".

#### Влияние на производительность

- **Производительность доступа**: В идеальных условиях (когда отсутствуют коллизии) время доступа к элементу (`get`
  и `put` операции) в `HashMap` может быть близко к O(1), т.е. константное время. Однако, при наличии коллизий, это
  время может увеличиваться, так как элементы в одном бакете хранятся в виде списка (или дерева, в зависимости от
  количества элементов в бакете) и для доступа к элементу необходимо пройтись по этому списку.
- **Память**: Увеличение ёмкости приводит к увеличению потребления памяти, поскольку создаётся больше бакетов для
  хранения элементов. Это важно учитывать при работе с очень большими наборами данных.

#### Коэффициент загрузки

- Вместе с понятием ёмкости тесно связан коэффициент загрузки (`loadFactor`), который представляет собой меру того,
  насколько плотно `HashMap` заполнена перед тем, как её ёмкость будет увеличена. Это значение, вещественное число
  меньшее 1, по умолчанию равное 0.75 в Java, что означает, что рехеширование произойдёт, когда `HashMap` будет
  заполнена на 75%.
- Коэффициент загрузки представляет собой компромисс между временем доступа и потреблением памяти, где более высокий
  коэффициент загрузки уменьшает потребление памяти за счёт некоторого увеличения времени доступа и наоборот.

### Доступные для модификации во время создания

- **loadFactor** — Коэффициент загрузки. Значение по умолчанию 0.75 является хорошим компромиссом между временем доступа
  и объемом хранимых данных;

```java
/**
 * Коэффициент загрузки, используемый, если он не указан в конструкторе.
 */
static final float DEFAULT_LOAD_FACTOR = 0.75f;
```

- **threshold** — Предельное количество элементов, при достижении которого, размер хэш-таблицы увеличивается вдвое.
  Рассчитывается по формуле (**capacity** * **loadFactor**);

### Остальные свойства, которые нам неподвластны

- **table** — Массив Node<K, V>[], который является хранилищем ссылок на списки (цепочки) значений;

- **modCount** — Количество структурных изменений в коллекции. Структурные изменения – это любые изменения, которые
  модифицируют структуру самого HashMap, такие как добавление, удаление элементов, очистка (**clear()**) или
  слияние (**merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction)**). Это поле
  используется для реализации fail-fast поведения итераторов.

### Важные константы

```java
/**
 * Начальная емкость - ДОЛЖНО быть степенью двойки.
 */
static final int DEFAULT_INITIAL_CAPACITY = 1 << 4; // 16 (2 в степени 4 или сдвиг в лево на 4)
//00000000 00000000 00000000 00000001 << 4 = 00000000 00000000 00000000 00010000
/**
 * Максимальная емкость, используется, если неявно указано более высокое значение
 * любым из конструкторов с аргументами.
 * ДОЛЖНО быть степенью двойки
 */
static final int MAXIMUM_CAPACITY = 1 << 30; // 1_073_741_824 - (2 в степени 30 или сдвиг в лево на 30)
//00000000 00000000 00000000 00000001 << 4 = 01000000 00000000 00000000 00000000


/**
 * The bin count threshold for using a tree rather than list for a
 * bin.  Bins are converted to trees when adding an element to a
 * bin with at least this many nodes. The value must be greater
 * than 2 and should be at least 8 to mesh with assumptions in
 * tree removal about conversion back to plain bins upon
 * shrinkage.
 */
static final int TREEIFY_THRESHOLD = 8;

/**
 * The bin count threshold for untreeifying a (split) bin during a
 * resize operation. Should be less than TREEIFY_THRESHOLD, and at
 * most 6 to mesh with shrinkage detection under removal.
 */
static final int UNTREEIFY_THRESHOLD = 6;

/**
 * The smallest table capacity for which bins may be treeified.
 * (Otherwise the table is resized if too many nodes in a bin.)
 * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts
 * between resizing and treeification thresholds.
 */
static final int MIN_TREEIFY_CAPACITY = 64;
```

## Создание объекта

```java
Map<String, String> hashmap = new HashMap<String, String>();
```

При таком создании объекта, вызывается конструктор по умолчанию:

```java
public HashMap() {
    this.loadFactor = DEFAULT_LOAD_FACTOR;
}
```

Инициализируется только loadFactor. Все остальные поля не проинициализированы (как пишут многие)

Новоявленный объект выглядит следующим образом:

| OFF | SZ | TYPE DESCRIPTION                        | VALUE                                     |
|-----|----|-----------------------------------------|-------------------------------------------|
| 0   | 8  | (object header: mark)                   | 0x0000000000000001 (non-biasable; age: 0) |
| 8   | 4  | (object header: class)                  | 0x000bb0d8                                |
| 12  | 4  | java.util.Set AbstractMap.keySet        | null                                      |
| 16  | 4  | java.util.Collection AbstractMap.values | null                                      |
| 20  | 4  | int HashMap.size                        | 0                                         |
| 24  | 4  | int HashMap.modCount                    | 0                                         |
| 28  | 4  | int HashMap.threshold                   | 0                                         |
| 32  | 4  | float HashMap.loadFactor                | 0.75                                      |
| 36  | 4  | java.util.HashMap.Node[] HashMap.table  | null                                      |
| 40  | 4  | java.util.Set HashMap.entrySet          | null                                      |
| 44  | 4  | (object alignment gap)                  |                                           |

Instance size: 48 bytes

Можно почитать тут: [Как вычисляется hashCode()](questions_of_interview.md#object-hashcode)

```java
import java.util.HashMap;

class Main {
    public static void main(String[] args) {
        new HashMap<>();
    }
}
```

Конструкторы

```java
    /**
 * Constructs an empty {@code HashMap} with the specified initial
 * capacity and load factor.
 *
 * @param  initialCapacity the initial capacity
 * @param  loadFactor      the load factor
 * @throws IllegalArgumentException if the initial capacity is negative
 *         or the load factor is nonpositive
 */
public HashMap(int initialCapacity, float loadFactor);

public HashMap(int initialCapacity) {
    this(initialCapacity, DEFAULT_LOAD_FACTOR);
}
```

Интересный метод

```java
    /**
 * Returns a power of two size for the given target capacity.
 */
static final int tableSizeFor(int cap) {
    int n = -1 >>> Integer.numberOfLeadingZeros(cap - 1);
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}


static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}

```

https://chat.openai.com/share/873aaf10-45e7-4745-80fc-9ba9a8275530