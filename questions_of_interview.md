# Вопросы по Java

* [Перечислите методы класса Object](#перечислите-методы-класса-object)
* [Коллекции (Collection)](#расскажите-про-коллекции-collection)
* [`wait`, `notify`, `notifyAll` и ключевое слово `synchronized`](#расскажите-про-методы-wait-notify-notifyall-и-ключевое-слово-synchronized)
* [Атомарная операция](#атомарная-греч-άτομος--неделимое-операция)
* [JMM. Зачем нужно volatile](#jmm-зачем-нужно-volatile)
* [Сборка мусора](#сборка-мусора-как-работает-какие-сборщики-знаете-какие-есть-области-памяти-в-jvm)
* [Паттерны проектирования](#паттерны-проектирования)

## Перечислите методы класса Object

* clone
* equals
* finalize (Deprecated)
* getClass
* hashCode
* toString
* notify
* notifyAll
* wait

## Расскажите про коллекции (Collection)?

Контр вопрос:

* Есть ли метод E get(int index) у LinkedList?

> Конечно есть, так как он реализует интерфейс List

## WeakReference – слабые ссылки

Если на объект не осталось обычных ссылок и мягких ссылок, а только слабые ссылки, то этот объект является живым, но он
будет уничтожен при ближайшей сборке мусора.

* WeakHashMap не предназначена для использования в качестве кэша. WeakReference создается для ключа а не для значения. И
  данные будут удалены только после того как в программе не останется strong-ссылок на ключ а не на значение. В
  большинстве случаев это не то чего вы хотите достичь кэшированием.
* Данные с WeakHashMap будут удалены не сразу после того как GC обнаружит что ключ доступен только через weak-ссылки.
  Фактически очистка произойдет при следующем обращении к WeakHashMap.
* В первую очередь WeakHashMap предназначен для использования с ключами, у которых метод equals проверяет идентичность
  объектов (использует оператор ==). Как только доступ к ключу потерян, его уже нельзя создать заново.

#### Общее Описание [ссылка](https://habr.com/ru/articles/169883/)

Для начала немного общей теории. Вспомним, в общих чертах, как работает Garbage Collector (далее GC). Если не вдаваться
в детали, то алгоритм прост: при запуске сборщика виртуальная машина рекурсивно находит, для всех потоков, все доступные
объекты в памяти и помечает их неким образом. А на следующем шаге GC удаляет из памяти все непомеченные объекты. Таким
образом, после чистки, в памяти будут находиться только те объекты, которые могут быть полезны программе. Идем дальше.
В Java есть несколько видов ссылок. Есть StrongReference — это самые обычные ссылки которые мы создаем каждый день.

```
StringBuilder builder = new StringBuilder();
```

**builder** это и есть strong-ссылка на объект StringBuilder.

И есть 3 «особых» типа ссылок — SoftReference, WeakReference, PhantomReference.

1. `SoftReference` — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти.
   Потом. Наверно.
2. `WeakReference` — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.
3. `PhantomReference` — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из
   памяти. После нескольких запусков GC

Эти 3 типа ссылок наследуются от одного родителя — `Reference`, у которого они собственно и берут все свои public методы
и конструкторы.

```
StringBuilder builder = new StringBuilder();
SoftReference<StringBuilder> softBuilder = new SoftReference(builder);
```

После выполнения этих двух строчек у нас будет 2 типа ссылок на 1 объект StringBuilder:

* builder — strong-ссылка
* softBuilder — soft-ссылка (формально это strong-ссылка на soft-ссылку, но для простоты я буду писать soft-ссылка)

И если во время выполнения программы, переменная builder станет недоступной, но при этом ссылка на объект, на который
ссылается softBuilder, будет еще доступна И запустится GC -> то объект StringBuilder будет помечен как доступный только
через цепочку soft-ссылок.

**Рассмотрим доступные методы:**
softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти. В
другом случае вернется null.
softBuilder.clear() — удалит ссылку на объект StringBuilder (то есть soft-ссылки на этот объект больше нет)
Все то же самое работает и для WeakReference и для PhantomReference. Правда, PhantomReference.get() всегда будет
возвращать null.

## всегда ли мы заходим в блок файнали?

## Как потерять ключ в мапе?

## Расскажите про методы `wait`, `notify`, `notifyAll` и ключевое слово `synchronized`.

`Метод wait()` У метода wait() есть три вариации. Один метод wait() бесконечно ждет другой поток, пока не будет
вызван метод notify() или notifyAll() на объекте. Другие две вариации метода wait() ставят текущий поток в ожидание на
определенное время. По истечении этого времени поток просыпается и продолжает работу.

`Метод notify()` Вызов метод notify() пробуждает только один поток, после чего этот поток начинает выполнение. Если
объект ожидают несколько потоков, то метод notify() разбудит только один из них. Выбор потока зависит от системной
реализации управления потоками.

`Метод notifyAll()` Метод notifyAll() пробуждает все потоки, хотя в какой последовательности они будут пробуждаться
зависит от реализации ОС.

## Атомарная (греч. άτομος — неделимое) операция

Атомарная (греч. άτομος — неделимое) операция — операция, которая либо выполняется целиком, либо не выполняется вовсе;
Операция, которая не может быть частично выполнена и частично не выполнена.

### JMM. Зачем нужно volatile

[раз](https://www.youtube.com/watch?v=CI_rOvL-OTE)

Если необходимо синхронизировать переменную между потоками, ее необходимо пометить как volatile (изменчивый)
volatile - гарантирует когерентность кэша ядер. При этом переменная, помеченная volatile, не будет кешироваться в
кеше каждого ядра, а будет располагаться в главной памяти и каждый поток будет обращаться главной памяти,
чтоб взять свежее значение переменной.

**Итог:**
> Если один поток записывает в переменную, а другой потом читает ее, то ее необходимо всегда помечать как volatile

Когерентность кэша (англ. cache coherence) — свойство кэшей, означающее целостность данных, хранящихся в локальных
кэшах для разделяемого ресурса.

## Сборка мусора. Как работает? Какие сборщики знаете? Какие есть области памяти в JVM?

Что будет с двумя или более объектами, которые ссылаются только друг на друга,
но больше не на кого и никому не нужны - как с ними поступит сборщик и как именно это будет делать?

## Список паттернов проектирования:

[раз](https://javarush.com/quests/lectures?quest=QUEST_JRU_JAVA_PROFESSIONAL&level=16),
[два](https://javarush.com/quests/lectures/questservlets.level16.lecture00)

 ```
 B — поведенческие (behavioral)    
 C — порождающие (creational)    
 S — структурные (structural)

 C — Абстрактная фабрика
 S — Адаптер
 S — Мост
 C — Строитель
 B — Цепочка обязанностей
 B — Команда
 S — Компоновщик
 S — Декоратор
 S — Фасад
 C — Фабричный метод
 S — Приспособленец
 B — Интерпретатор
 B — Итератор
 B — Посредник
 B — Хранитель
 C — Прототип
 S — Прокси
 B — Наблюдатель
 C — Одиночка
 B — Состояние
 B — Стратегия
 B — Шаблонный метод
 B — Посетитель
 ```

## Внедрение зависимостей - это специальный паттерн, который уменьшает связь между Spring компонентами.

Таким образом, при применении DI, ваш код становится чище, проще, его становится легче понять и тестировать.
Согласно паттерну DI, создание объектов для зависимостей переходит на фабрику или отдается третьей стороне.
Это означает, что мы можем сосредоточиться на использовании этих объектов вместо их создания.

## Преимущества DI:

- Уменьшенная связь между частями приложения
- Улучшенное тестирование
- Улучшенная архитектура приложения
- Уменьшает шаблонный код
- Стандартизирует разработку приложения

## Почему для создания Spring beans рекомендуются интерфейсы?

- Улучшенное тестирование. В тестах бин может быть заменен специальным объектом(mock или stub), который реализует
  интерфейс бина.
- Позволяет использовать механизм динамических прокси из JDK(например, при создании репозитория через Spring Data)
- Позволяет скрывать реализацию

## 14. Что такое application context?

В Spring Framework интерфейс org.springframework.factory.BeanFactory предоставляет фабрику для бинов, которая в то
же время является IoC контейнером приложения.
Управление бинами основано на конфигурации(java или xml).

Интерфейс org.springframework.context.ApplicationContext — это обертка над bean factory, предоставляющая некоторые
дополнительные возможности,
например AOP, транзакции, безопасность, i18n, и т.п.

## Что такое контейнер и какой у него жизненный цикл?

Основа Spring Framework — контейнер, и наши объекты "живут" в этом контейнере.
Контейнер обычно создает множество объектов на основе их конфигураций и управляет их жизненным циклом от создания
объекта до уничтожения.

Контейнер — это объект, реализующий интерфейс ApplicationContext.

#### Жизненный цикл контейнера:

- Контейнер создается при запуске приложения
- Контейнер считывает конфигурационные данные
- Из конфигурационных данных создается описание бинов
- BeanFactoryPostProcessors обрабатывают описание бина
- Контейнер создает бины используя их описание
- Бины инициализируются — значения свойств и зависимости внедряются в бин
- BeanPostProcessor запускают методы обратного вызова(callback methods)
- Приложение запущено и работает
- Инициализируется закрытие приложения
- Контейнер закрывается
- Вызываются callback methods

## Как создать экземпляр ApplicationContext?

Spring обеспечивает несколько разновидностей контекста.

Есть несколько основных реализаций интерфейса ApplicationContext:

- FileSystemXmlApplicationContext
- ClassPathXmlApplicationContext
- AnnotationConfigApplicationContext
- XmlWebApplicationContext
- AnnotationConfigWebApplicationContext

#### Примеры создания контекста:

 ```
 ApplicationContext ctx = new FileSystemXmlApplicationContext("c:/bean_properties.xml");
 
 ApplicationContext ctx = new AnnotationConfigApplicationContext("com.springdemoapp.JavaConfig.class");
 ```

## Можете ли вы описать жизненный цикл бина в контейнере?

1. Загрузка описаний бинов, создание графа зависимостей(между бинами)
2. Создание и запуск BeanFactoryPostProcessors
3. Создание бинов
4. Spring внедряет значения и зависимости в свойства бина
5. Если бин реализует метод setBeanName() из интерфейса NameBeanAware, то ID бина передается в метод
6. Если бин реализует BeanFactoryAware, то Spring устанавливает ссылку на bean factory через setBeanFactory() из
   этого интерфейса.
7. Если бин реализует интерфейс ApplicationContextAware, то Spring устанавливает ссылку на ApplicationContext через
   setApplicationContext().
8. BeanPostProcessor это специальный интерфейс(о нем ниже), и Spring позволяет бинам имплементировать этот
   интерфейс.
   Реализуя метод postProcessBeforeInitialization(), можно изменить экземпляр бина перед его(бина) инициализацией(
   установка свойств и т.п.)
9. Если определены методы обратного вызова, то Spring вызывает их. Например, это метод, аннотированный
   @PostConstruct или метод initMethod из аннотации @Bean.
10. Теперь бин готов к использованию. Его можно получить с помощью метода ApplicationContext#getBean().
11. После того как контекст будет закрыт(метод close() из ApplicationContext), бин уничтожается.
12. Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод.
    Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy(),
    чтобы очистить ресурсы или убить процессы в приложении.
    Если в аннотации @Bean определен метод destroyMethod, то вызовется и он.

## 18. Как получить ApplicationContext в интеграционном тесте?

Если вы используете JUnit 5, то вам нужно указать 2 аннотации:
@ExtendWith(TestClass.class) — используется для указания тестового класса
@ContextConfoguration(classes = JavaConfig.class) — загружает java/xml конфигурацию для создания контекста в тесте

Можно использовать аннотацию @SpringJUnitConfig, которая сочетает обе эти аннотации.
Для теста веб-слоя можно использовать аннотацию @SpringJUnitWebConfig.

## Потоки в SpringBoot. Откуда берутся? Сколько по умолчанию? Как управлять количеством?

## Различия 8, 9, 11, 17 версий java

## 10. Java 8 (Что нового)

https://javarush.com/groups/posts/2547-iz-8-v-13-polnihy-obzor-versiy-java-chastjh-1

1. Functional Interface (Функциональный интерфейс) — это интерфейс, содержащий один нереализованный (абстрактный)
   метод.
   @FunctionalInterface — необязательная аннотация, которая ставится над таким интерфейсом.
   Нужна для проверки того, соответствует ли он требованиям функционального интерфейса (наличие только одного
   абстрактного метода).

2. Stream (Стримы) — это способ обрабатывать структуры данных в функциональном стиле.
   Как правило это коллекции (но можно использовать их в других, менее распространённых ситуациях).
   Более понятным языком, Stream — это поток данных, который мы обрабатываем как бы работая со всеми данными
   одновременно,
   а не перебором, как при for-each.

3. Lambda - Это блок кода, который можно передать в различные места, исходя из этого он может быть выполнен позже
   столько раз, сколько потребуется.

4. foreach - который работает с потоком данных как и стрим.

5. Method reference (Ссылочные методы) — это новый полезный синтаксис, созданный чтобы ссылаться на существующие
   методы или конструкторы Java-классов или объектов через ::

6. API Time - библиотека для работы с датами и временем — java.time. Новый API схож с любой Joda-Time.

7. Optional - Это новый класс в пакете java.util, обёртка (контейнер) для значений, фишкой которой является то, что
   она также может безопасно содержать null.

## 11. Java 9 (Что нового)

[раз](https://javarush.com/groups/posts/2547-iz-8-v-13-polnihy-obzor-versiy-java-chastjh-1#:~:text=8%20Tutorial.-,Java%209,-%D0%98%D1%82%D0%B0%D0%BA%2C%2021%20%D1%81%D0%B5%D0%BD%D1%82%D1%8F%D0%B1%D1%80%D1%8F)

1. JShell (REPL — read-eval-print loop) - Это реализация в Java интерактивной консоли,
   которая используется для тестирования функционала и использования в консоли разных конструкций,
   например интерфейсов, классов, enum, операторов и т.д.

   Для запуска JShell нужно лишь написать в терминале — jshell.

2. Private - Начиная с 9 версии Java, у нас появилась возможность использовать private методы в интерфейсах
   (default и static методы, так как другие мы попросту не можем переопределить из-за недостаточного доступа).

3. Immutable Collection - стало возможным создание и заполнение коллекции одной строкой, при этом делая её immutable
   (ранее для создания immutable коллекции нам нужно было создать коллекцию, заполнить её данными, и вызов метода,
   например — Collections.unmodifiableList).

4. Расширен Optional (добавлены новые методы);
5. Появились интерфейсы ProcessHandle и ProcessHandle для управления действиями операционной системы;
6. G1 — дефолтный сборщик мусора;
7. HTTP клиент с поддержкой как HTTP/2 протокола и WebSocket;
8. Расширен Stream;
9. Добавлен фреймворк Reactive Streams API (для реактивного программирования);

## Стирание типов

## Дженерики

## Многопоточность

## Создание потоков

## deadlock

## Race condition

## Неоднозначность бинов

## Виды прокси

## Паттерны проектирования

## Динамическая диспетчерезация

## Тред пулл

## Streap api паралельное

## 20. При создании строки через оператор new, она помещается в heap (Оператор new выделяет новый участок памяти в хипе)

## IoC

IoC - инверсия управления может быть разделена на два подтипа: внедрение зависимостей и поиск зависимостей. Эти
подтипы подразделяются далее на конкретные реализации служб инверсии управления. Из этого определения ясно видно,
что когда речь идет о внедрении зависимостей, всегда имеется в виду инверсия управления. Но когда речь идет об
инверсии управления,
то не всегда имеется в виду внедрение зависимостей. Например, поиск зависимостей - это также форма инверсии
управления.

Первый тип - поиск зависимостей - является намного более традиционным подходом и на первый взгляд выглядит более
знакомым тем,
кто программирует на Java. Второй тип - внедрения зависимостей - в действительности обеспечивает более высокую
гибкость
и удобство применения по сравнению с поиском зависимостей, хотя поначалу он кажется нелогичным.

Если инверсия управления реализуется как поиск зависимостей, то компонент должен получить ссылку на зависимость,
тогда как при внедрении зависимостей последние внедряются в компонент контейнером инверсии управления.
У поиска зависимостей имеются две разновидности: извлечение зависимостей и контекстный поиск зависимостей (CDL).
И у внедрения зависимостей имеются две разновидности: через конструктор и через метод установки.

#### Извлечение зависимостей:

Для разработчика приложений на Java извлечение зависимостей является самым узнаваемым типом инверсии управления.
В этом случае зависимости извлекаются из реестра по мере необходимости. Всякий, кому приходилось писать код для
доступа
к каркасу EJB (вплоть до версии 2.1), пользовался извлечением зависимостей (через прикладной интерфейс JNDI API
для поиска компонента ЕJВ).
![img.png](assets/images/3.1img.png)

Извлечение зависимостей предоставляется и в каркасе Spring как механизм для извлечения компонентов, которыми он
управляет.

**Пример:**

```java
public class DependencyPull {
    public static void main(String... args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("spring/app-context.xml");
        MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
        mr.render();
    }
}
```        

Этот тип инверсии управления не только преобладает в приложениях на платформе JEE,
где применяется каркас EJB вплоть до версии 2.1 и широко употребляются операции поиска в службе JNDI
для получения зависимостей из реестра, но и играет ключевую роль в работе с Spring во многих средах.

#### Контекстный поиск зависимостей:

В известной мере контекстный поиск зависимостей (CDL) nодобен извлечению зависимостей,
но в этом случае поиск осуществляется в контейнере, управляющем ресурсом, а не только в каком-то центральном
реестре.
Как правило, контекстный поиск зависимостей производится в установленной точке.

![img.png](assets/images/3,2img.png)

Механизм контекстного поиска приводится в действие через реализацию в компоненте интерфейса,
аналогично приведенному в следующем фрагменте кода:

```java
public interface ManagedComponent {
    void performLookup(Container container);
}
```

Реализуя этот интерфейс, комnонент извещает контейнер, что ему требуется получить зависимость.
Контейнер обычно предоставляется базовым сервером приложений (например, Tomcat или JBoss)
или каркасом (в частности, Spring). В следующем фрагменте кода приведен простой интерфейс Container,
предоставляющий услуги поиска зависимостей:

```java
public interface Container {
    Object getDependency(String key);
}
```

Как только контейнер будет готов передать зависимости компоненту, он вызовет метод performLookup()
по очереди для каждого компонента. И тогда компонент сможет искать свои зависимости,
используя интерфейс Container, как показано в следующем фрагменте кода:

```java
public class ContextualizedDependencyLookup implements ManagedComponent {
    private Dependency dependency;

    @Override
    public void performLookup(Container container) {
        this.dependency = (Dependency) container.getDependency("myDependency");
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
```

#### Внедрение зависимостей через конструктор

Внедрение зависимостей через конструктор происходит в том случае, когда зависимости предоставляются компоненту в его
конструкторе (или нескольких конструкторах). С этой целью в компоненте объявляется один или ряд конструкторов,
получающих в качестве аргументов его зависимости, а контейнер инверсии управления передает зависимости компоненту при
получении его экземпляра, как показано в приведенном ниже фрагменте кода. Очевидно, что вследствие внедрения
зависимостей через конструктор объект не может быть создан без зависимостей, а следовательно, они обязательны.

```java
public class ConstructorInjection {
    private Dependency dependency;

    public ConstructorInjection(Dependency dependency) {
        this.dependency = dependency;
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
```

#### Внедрение зависимостей через метод установки

При внедрении зависимостей через метод установки контейнер инверсии управления внедряет зависимости компонента через
методы установки в стиле компонентов JavaBeans. Методы установки компонента отражают зависимости, которыми может
управлять контейнер инверсии управления. В приведенном ниже фрагменте кода показан типичный компонент, основанный на
внедрении зависимостей через метод установки. Очевидно, что вследствие внедрения зависимостей через метод установки
объект может быть создан без зависимостей, которые могут быть предоставлены в дальнейшем через вызов метода установки.

```java
public class SetterInjection {
    private Dependency dependency;

    public void setDependency(Dependency dependency) {
        this.dependency = dependency;
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
```

Требование зависимости, предоставляемое через метод setDependency(), обозначается в контейнере по имени в стиле
компонентов JavaBeans (в данном случае - dependency). На практике внедрение зависимостей через метод установки
оказывается наиболее широко применяемым механизмом инверсии управления, который проще всего реализовать.

#### Выбор между внедрением и поиском зависимостей

Выбрать конкретный тип инверсии управления для применения - внедрение или поиск зависимостей - обычно не трудно. Как
правило, выбор типа инверсии управления зависит от применяемого контейнера. Так, если применяется каркас EJB (вплоть до
версии 2.1), то следует выбрать инверсию управления в стиле поиска (через службу JNDI), чтобы получить доступ к ЕJВ из
контейнера JEE. А в Spring компоненты и их зависимости всегда связываются вместе с помощью инверсии управления в стиле
внедрения, за исключением первоначальных поисков компонентов Spring Beans.

**На заметку**
> Применяя Spriпg, можно получить доступ к ресурсам EJB, и не прибегая
> к явному поиску. Каркас Spring может действовать в роли адаптера между системами инверсии
> управления в стиле поиска и внедрения, позволяя таким образом управлять всеми ресурсами
> с помощью внедрения.

Вопрос на самом деле заключается в следующем: когда есть выбор, то какой тип инверсии управления должен использоваться:
внедрение или поиск зависимостей? Очевидно, что внедрение. Если обратиться к приведенным выше примерам исходного кода,
то можно заметить, что внедрение зависимостей не оказывает никакого влияния на исходный код компонентов. С другой
стороны, код, реализующий извлечение зависимостей, должен активно получать ссылку на реестр и взаимодействовать с ним
при получении зависимостей, а для применения контекстного поиска зависимостей требуется, чтобы в классах был реализован
конкретный интерфейс и поиск зависимостей вручную. Если же выбрать внедрение зависимостей, то в классах достаточно
разрешить их внедрение через конструкторы или же через методы установки. Выбрав внедрение зависимостей, можно
пользоваться своими классами полностью отдельно от контейнера инверсии управления, который поставляет зависимые объекты
и взаимодействующие с ними объекты вручную, тогда как при поиске зависимостей классы всегда будут зависеть от классов и
интерфейсов, определяемых в контейнере инверсии управления. Еще один недостаток поиска зависимостей состоит в том, что
он сильно затрудняет тестирование классов отдельно от контейнера. А при внедрении зависимостей тестирование компонентов
не составит особого труда, поскольку для этого достаточно предоставить зависимости с помощью подходящего конструктора
или метода установки.

Решения на основе поиска зависимостей неизбежно оказываются более сложными, чем решения, основанные на внедрении
зависимостей. И хотя такой сложности не следует бояться, мы ставим под сомнение обоснованность излишнего усложнения
процесса в целом, поскольку считаем этот аспект не менее важным, чем управление зависимостями в приложении. Если
оставить все эти второстепенные причины в стороне, то главной причиной для выбора внедрения, а не поиска зависимостей
является значительное упрощение задачи разработки. Если выбрать внедрение зависимостей, то придется написать намного
меньше кода, который окажется несложным и, как правило, генерируемым автоматически в хорошей IDE. Обратите внимание на
то, что весь код в примерах внедрения зависимостей является пассивным в том смысле, что он не пытается активно выполнить
какую-то задачу. Но самое примечательное в таком коде состоит в том, что получаемые обьекты хранятся только в полях, а
для извлечения зависимости из любого реестра или контейнера никакого другого кода не требуется. Таким образом, код
оказывается намного более простым и менее подверженным ошибкам. Пассивный код легче сопровождать, чем активный,
поскольку в нем мало что может пойти не так. Рассмотрим следующий фрагмент кода, взятый из приведенного выше примера
контекстного поиска зависимостей:

```
public void performLookup(Container container){
   this.dependency=(Dependency)
   container.getDependency("myDependency");
}
```

В этом коде многое может пойти не так, как было задумано: ключ зависимости может измениться, экземпляр контейнера может
оказаться пустым (null), а возвращаемая зависимость - относиться к неподходящему типу. Мы привели этот код потому, что
он содержит большое количество подвижных частей, и в нем может быть многое нарушено. Внедрение зависимостей способствует
развязке компонентов в приложении, но в то же время усложняет дополнительный код, который требуется для того, чтобы
связать эти компоненты вместе и решить любые полезные задачи.

## Разница IoC и DI [ссылка](https://habr.com/ru/articles/131993/)

Inversion of Control IoC (инверсия управления) - это абстрактный принцип, набор рекомендаций для написания слабо
связанного кода.
Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других,
не полагаясь в своей работе на детали конкретной реализации других компонентов.
Dependency injection DI (внедрение зависимостей) — это одна из реализаций IoC принципа (помимо этого есть еще
Factory Method, Service Locator).

[Factory Method](https://habr.com/ru/articles/556512/)

[Service Locator](https://habr.com/ru/companies/otus/articles/694458/)

IoC-контейнер — это какая-то библиотека, фреймворк, программа если хотите,
которая позволит вам упростить и автоматизировать написание кода с использованием данного подхода на столько, на
сколько это возможно.

## Been - класс, который создается и конфигурируется внутри контекста...

## Диспатчер сервлет и контроллер

## 24. SOLID (Депенденси инверсион. тест дривоп девелопмент (разработка через тестирование))

Tranzactional inbox (20:00) [раз](https://www.youtube.com/watch?v=ajU9HZP6q8c)

## 21. Транзакция

Транзакция - группа последовательных операций с одной БД, которая предсавляет собой логическую единицу работы с
данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно
идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эфекта.
[раз](https://www.youtube.com/watch?v=QZ9rXZT0DlQ&t=2s) https://habr.com/ru/companies/rosbank/articles/707378/)
	