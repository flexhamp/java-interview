### Вопросы по Java

### 1. Перечислите методы класса Object
    * clone
    * equals
    * finalize (Deprecated)
    * getClass
    * hashCode
    * toString
    * notify
    * notifyAll
    * wait

### 2. Расскажите про коллекции?

контр вопрос:
   * Еcть ли метод get(integer index) у LinkedList?
   * Реализован ли итератор у ArrayList?

### 3. Слабо связные ссылки?

### 4. всегда ли мы заходим в блок файнали?

### 5. как потерять ключ в мапе?

### 6. Расскажите про методы `wait`, `notify`, `notifyAll` и ключевое слово `synchronized`.

### 7. Атомарная (греч. άτομος — неделимое) операция — операция,

которая либо выполняется целиком, либо не выполняется вовсе;
операция, которая не может быть частично выполнена и частично не выполнена.

### 8. JMM. Зачем нужно volatile. Популярный вопрос.

(https://www.youtube.com/watch?v=CI_rOvL-OTE)

Если необходимо синхронизировать переменную между потоками, ее необходимо пометить как volatile (изменчивый)
volatile - гарантирует когерентность кэша ядер. При этом переменная, помеченная volatile, не будет кешироваться в
кеше каждого ядра,
а будет распологаться в главной памяти и каждый поток будет обращаться г лавной памяти, чтоб взять свежее значение
переменной.

Итог: Если один поток записывает в переменную, а другой потом читает ее, то ее необходимо всегда помечать как
volatile

Когерентность кэша (англ. cache coherence) — свойство кэшей, означающее целостность данных, хранящихся в локальных
кэшах для разделяемого ресурса.

### 9. Сборка мусора. Как работает? Какие сборщики знаете? Какие есть области памяти в JVM?

Что будет с двумя или более объектами, которые ссылаются только друг на друга,
но больше не на кого и никому не нужны - как с ними поступит сборщик и как именно это будет делать?

### 10. Список паттернов проектирования:

[раз](https://javarush.com/quests/lectures?quest=QUEST_JRU_JAVA_PROFESSIONAL&level=16),
[два](https://javarush.com/quests/lectures/questservlets.level16.lecture00)

    ```
    B — поведенческие (behavioral)    
    C — порождающие (creational)    
    S — структурные (structural)

    C — Абстрактная фабрика
    S — Адаптер
    S — Мост
    C — Строитель
    B — Цепочка обязанностей
    B — Команда
    S — Компоновщик
    S — Декоратор
    S — Фасад
    C — Фабричный метод
    S — Приспособленец
    B — Интерпретатор
    B — Итератор
    B — Посредник
    B — Хранитель
    C — Прототип
    S — Прокси
    B — Наблюдатель
    C — Одиночка
    B — Состояние
    B — Стратегия
    B — Шаблонный метод
    B — Посетитель
    ```

### 11. Внедрение зависимостей - это специальный паттерн, который уменьшает связь между Spring компонентами.

    Таким образом, при применении DI, ваш код становится чище, проще, его становится легче понять и тестировать.
    Согласно паттерну DI, создание объектов для зависимостей переходит на фабрику или отдается третьей стороне.
    Это означает, что мы можем сосредоточиться на использовании этих объектов вместо их создания.

### 12. Преимущества DI:

    - Уменьшенная связь между частями приложения
    - Улучшенное тестирование
    - Улучшенная архитектура приложения
    - Уменьшает шаблонный код
    - Стандартизирует разработку приложения

### 13. Почему для создания Spring beans рекомендуются интерфейсы?

    - Улучшенное тестирование. В тестах бин может быть заменен специальным объектом(mock или stub), который реализует
      интерфейс бина.
    - Позволяет использовать механизм динамических прокси из JDK(например, при создании репозитория через Spring Data)
    - Позволяет скрывать реализацию

### 14. Что такое application context?

    В Spring Framework интерфейс org.springframework.factory.BeanFactory предоставляет фабрику для бинов, которая в то
    же время является IoC контейнером приложения.
    Управление бинами основано на конфигурации(java или xml).

    Интерфейс org.springframework.context.ApplicationContext — это обертка над bean factory, предоставляющая некоторые
    дополнительные возможности,
    например AOP, транзакции, безопасность, i18n, и т.п.

### 15. Что такое контейнер и какой у него жизненный цикл?

    Основа Spring Framework — контейнер, и наши объекты "живут" в этом контейнере.
    Контейнер обычно создает множество объектов на основе их конфигураций и управляет их жизненным циклом от создания
    объекта до уничтожения.

    Контейнер — это объект, реализующий интерфейс ApplicationContext.

    Жизненный цикл контейнера:
    - Контейнер создается при запуске приложения
    - Контейнер считывает конфигурационные данные
    - Из конфигурационных данных создается описание бинов
    - BeanFactoryPostProcessors обрабатывают описание бина
    - Контейнер создает бины используя их описание
    - Бины инициализируются — значения свойств и зависимости внедряются в бин
    - BeanPostProcessor запускают методы обратного вызова(callback methods)
    - Приложение запущено и работает
    - Инициализируется закрытие приложения
    - Контейнер закрывается
    - Вызываются callback methods

### 16. Как создать экземпляр ApplicationContext?

    Spring обеспечивает несколько разновидностей контекста.

    Есть несколько основных реализаций интерфейса ApplicationContext:
    - FileSystemXmlApplicationContext
    - ClassPathXmlApplicationContext
    - AnnotationConfigApplicationContext
    - XmlWebApplicationContext
    - AnnotationConfigWebApplicationContext

    #### Примеры создания контекста:
    ```
    ApplicationContext ctx = new FileSystemXmlApplicationContext("c:/bean_properties.xml");
    
    ApplicationContext ctx = new AnnotationConfigApplicationContext("com.springdemoapp.JavaConfig.class");
    ```

### 17. Можете ли вы описать жизненный цикл бина в контейнере?

    1. Загрузка описаний бинов, создание графа зависимостей(между бинами)
    2. Создание и запуск BeanFactoryPostProcessors
    3. Создание бинов
    4. Spring внедряет значения и зависимости в свойства бина
    5. Если бин реализует метод setBeanName() из интерфейса NameBeanAware, то ID бина передается в метод
    6. Если бин реализует BeanFactoryAware, то Spring устанавливает ссылку на bean factory через setBeanFactory() из
       этого интерфейса.
    7. Если бин реализует интерфейс ApplicationContextAware, то Spring устанавливает ссылку на ApplicationContext через
       setApplicationContext().
    8. BeanPostProcessor это специальный интерфейс(о нем ниже), и Spring позволяет бинам имплементировать этот
       интерфейс.
       Реализуя метод postProcessBeforeInitialization(), можно изменить экземпляр бина перед его(бина) инициализацией(
       установка свойств и т.п.)
    9. Если определены методы обратного вызова, то Spring вызывает их. Например, это метод, аннотированный
       @PostConstruct или метод initMethod из аннотации @Bean.
    10. Теперь бин готов к использованию. Его можно получить с помощью метода ApplicationContext#getBean().
    11. После того как контекст будет закрыт(метод close() из ApplicationContext), бин уничтожается.
    12. Если в бине есть метод, аннотированный @PreDestroy, то перед уничтожением вызовется этот метод.
        Если бин имплементирует DisposibleBean, то Spring вызовет метод destroy(),
        чтобы очистить ресурсы или убить процессы в приложении.
        Если в аннотации @Bean определен метод destroyMethod, то вызовется и он.

### 18. Как получить ApplicationContext в интеграционном тесте?

    Если вы используете JUnit 5, то вам нужно указать 2 аннотации:
    @ExtendWith(TestClass.class) — используется для указания тестового класса
    @ContextConfoguration(classes = JavaConfig.class) — загружает java/xml конфигурацию для создания контекста в тесте

    Можно использовать аннотацию @SpringJUnitConfig, которая сочетает обе эти аннотации.
    Для теста веб-слоя можно использовать аннотацию @SpringJUnitWebConfig.

### Потоки в спринг буут. Откуда берутся? сколько по умолчанию? Как управлять количеством?

### Различия 8,9,11,17 версий java

### 10. Java 8 (Что нового)

https://javarush.com/groups/posts/2547-iz-8-v-13-polnihy-obzor-versiy-java-chastjh-1

1. Functional Interface (Функциональный интерфейс) — это интерфейс, содержащий один нереализованный (абстрактный)
   метод.
   @FunctionalInterface — необязательная аннотация, которая ставится над таким интерфейсом.
   Нужна для проверки того, соответствует ли он требованиям функционального интерфейса (наличие только одного
   абстрактного метода).

2. Stream (Стримы) — это способ обрабатывать структуры данных в функциональном стиле.
   Как правило это коллекции (но можно использовать их в других, менее распространённых ситуациях).
   Более понятным языком, Stream — это поток данных, который мы обрабатываем как бы работая со всеми данными
   одновременно,
   а не перебором, как при for-each.

3. Lambda - Это блок кода, который можно передать в различные места, исходя из этого он может быть выполнен позже
   столько раз, сколько потребуется.

4. foreach - который работает с потоком данных как и стрим.

5. Method reference (Ссылочные методы) — это новый полезный синтаксис, созданный чтобы ссылаться на существующие
   методы или конструкторы Java-классов или объектов через ::

6. API Time - библиотека для работы с датами и временем — java.time. Новый API схож с любой Joda-Time.

7. Optional - Это новый класс в пакете java.util, обёртка (контейнер) для значений, фишкой которой является то, что
   она также может безопасно содержать null.

### 11. Java 9 (Что нового)

https://javarush.com/groups/posts/2547-iz-8-v-13-polnihy-obzor-versiy-java-chastjh-1#:~:text=8%20Tutorial.-,Java%209,-%D0%98%D1%82%D0%B0%D0%BA%2C%2021%20%D1%81%D0%B5%D0%BD%D1%82%D1%8F%D0%B1%D1%80%D1%8F

1. JShell (REPL — read-eval-print loop) - Это реализация в Java интерактивной консоли,
   которая используется для тестирования функционала и использования в консоли разных конструкций,
   например интерфейсов, классов, enum, операторов и т.д.

   Для запуска JShell нужно лишь написать в терминале — jshell.

2. Private - Начиная с 9 версии Java, у нас появилась возможность использовать private методы в интерфейсах
   (default и static методы, так как другие мы попросту не можем переопределить из-за недостаточного доступа).

3. Immutable Collection - стало возможным создание и заполнение коллекции одной строкой, при этом делая её immutable
   (ранее для создания immutable коллекции нам нужно было создать коллекцию, заполнить её данными, и вызов метода,
   например — Collections.unmodifiableList).

4. Расширен Optional (добавлены новые методы);
5. Появились интерфейсы ProcessHandle и ProcessHandle для управления действиями операционной системы;
6. G1 — дефолтный сборщик мусора;
7. HTTP клиент с поддержкой как HTTP/2 протокола и WebSocket;
8. Расширен Stream;
9. Добавлен фреймворк Reactive Streams API (для реактивного программирования);

### Стирание типов

### Дженерики

### Многопоточность

### Создание потоков

### deadlock

### Race condition

### Неоднозначность бинов

### Виды прокси

### Паттерны проектирования

### Динамическая диспетчерезация

### Тред пулл

### Streap api паралельное

### 20. При создании строки через оператор new, она помещается в heap (Оператор new выделяет новый участок памяти в хипе)

### 21. IoC

IoC - инверсия управления может быть разделена на два подтипа: внедрение зависимостей и поиск зависимостей. Эти
подтипы подразделяются далее на конкретные реализации служб инверсии управления. Из этого определения ясно видно,
что когда речь идет о внедрении зависимостей, всегда имеется в виду инверсия управления. Но когда речь идет об
инверсии управления,
то не всегда имеется в виду внедрение зависимостей. Например, поиск зависимостей - это также форма инверсии
управления.

Первый тип - поиск зависимостей - является намного более традиционным подходом и на первый взгляд выглядит более
знакомым тем,
кто программирует на Java. Второй тип - внедрения зависимостей - в действительности обеспечивает более высокую
гибкость
и удобство применения по сравнению с поиском зависимостей, хотя поначалу он кажется нелогичным.

Если инверсия управления реализуется как поиск зависимостей, то компонент должен получить ссылку на зависимость,
тогда как при внедрении зависимостей последние внедряются в компонент контейнером инверсии управления.
У поиска зависимостей имеются две разновидности: извлечение зависимостей и контекстный поиск зависимостей (CDL).
И у внедрения зависимостей имеются две разновидности: через конструктор и через метод установки.

### Извлечение зависимостей:

Для разработчика приложений на Java извлечение зависимостей является самым узнаваемым типом инверсии управления.
В этом случае зависимости извлекаются из реестра по мере необходимости. Всякий, кому приходилось писать код для
доступа
к каркасу EJB (вплоть до версии 2.1), пользовался извлечением зависимостей (через прикладной интерфейс JNDI API
для поиска компонента ЕJВ).
![img.png](assets/images/3.1img.png)

Извлечение зависимостей предоставляется и в каркасе Spring как механизм для извлечения компонентов, которыми он
управляет.

#### Пример:

```java
public class DependencyPull {
    public static void main(String... args) {
        ApplicationContext ctx = new ClassPathXmlApplicationContext("spring/app-context.xml");
        MessageRenderer mr = ctx.getBean("renderer", MessageRenderer.class);
        mr.render();
    }
}
```        

Этот тип инверсии управления не только преобладает в приложениях на платформе JEE,
где применяется каркас EJB вплоть до версии 2.1 и широко употребляются операции поиска в службе JNDI
для получения зависимостей из реестра, но и играет ключевую роль в работе с Spring во многих средах.

### Контекстный поиск зависимостей:

В известной мере контекстный поиск зависимостей (CDL) nодобен извлечению зависимостей,
но в этом случае поиск осуществляется в контейнере, управляющем ресурсом, а не только в каком-то центральном
реестре.
Как правило, контекстный поиск зависимостей производится в установленной точке.

Механизм контекстного поиска приводится в действие через реализацию в компоненте интерфейса,
аналогично приведенному в следующем фрагменте кода:

```java
public interface ManagedComponent {
    void performLookup(Container container);
}
```

Реализуя этот интерфейс, комnонент извещает контейнер, что ему требуется получить зависимость.
Контейнер обычно предоставляется базовым сервером приложений (например, Tomcat или JBoss)
или каркасом (в частности, Spring). В следующем фрагменте кода приведен простой интерфейс Container,
предоставляющий услуги поиска зависимостей:

```java
public interface Container {
    Object getDependency(String key);
}
```

Как только контейнер будет готов передать зависимости компоненту, он вызовет метод performLookup()
по очереди для каждого компонента. И тогда компонент сможет искать свои зависимости,
используя интерфейс Container, как показано в следующем фрагменте кода:

```java
public class ContextualizedDependencyLookup implements ManagedComponent {
    private Dependency dependency;

    @Override
    public void performLookup(Container container) {
        this.dependency = (Dependency) container.getDependency("myDependency");
    }

    @Override
    public String toString() {
        return dependency.toString();
    }
}
```

### 21. Разница IoC и DI (https://habr.com/ru/articles/131993/)

    Inversion of Control IoC (инверсия управления) - это абстрактный принцип, набор рекомендаций для написания слабо
    связанного кода.
    Суть которого в том, что каждый компонент системы должен быть как можно более изолированным от других,
    не полагаясь в своей работе на детали конкретной реализации других компонентов.
    Dependency injection DI (внедрение зависимостей) — это одна из реализаций IoC принципа (помимо этого есть еще
    Factory Method, Service Locator).

    Factory Method (https://habr.com/ru/articles/556512/)
    Service Locator (https://habr.com/ru/companies/otus/articles/694458/)

    IoC-контейнер — это какая-то библиотека, фреймворк, программа если хотите,
    которая позволит вам упростить и автоматизировать написание кода с использованием данного подхода на столько, на
    сколько это возможно.

### 22. Been - класс, который создается и конфигурируется внутри контекста...

### 23. Диспатчер сервлет и контроллер

### 24. SOLID (Депенденси инверсион. тест дривоп девелопмент (разработка через тестирование))

Tranzactional inbox (20:00) https://www.youtube.com/watch?v=ajU9HZP6q8c   ?

### 21. Транзакция

Транзакция - группа последовательных операций с одной БД, которая предсавляет собой логическую единицу работы с
данными. Транзакция может быть выполнена либо целиком и успешно, соблюдая целостность данных и независимо от параллельно
идущих других транзакций, либо не выполнена вообще, и тогда она не должна произвести никакого эфекта.
[раз](https://www.youtube.com/watch?v=QZ9rXZT0DlQ&t=2s) https://habr.com/ru/companies/rosbank/articles/707378/)
	